"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfuBotMember = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const connection_1 = require("./connection");
const forwarding_1 = require("./forwarding");
const log = new common_1.Logger('packages/sfu-client/src/member.ts');
class SfuBotMember extends core_1.MemberImpl {
    /**@internal */
    constructor(args) {
        super(args);
        this.side = 'remote';
        this.subtype = SfuBotMember.subtype;
        this.type = 'bot';
        this._connections = {};
        this.onForwardingStarted = new common_1.Event();
        this.onForwardingStopped = new common_1.Event();
        this.onForwardingStateChanged = new common_1.Event();
        this._api = args.api;
        this._context = args.context;
        this.onLeft.once(() => {
            log.debug('SfuBotMember left: ', { id: this.id });
            Object.values(this._connections).forEach((c) => {
                c.close();
            });
            this._connections = {};
        });
    }
    /**@private */
    _getConnection(localPersonId) {
        return this._connections[localPersonId];
    }
    /**@private */
    _getOrCreateConnection(localPersonId) {
        var _a;
        const connection = (_a = this._getConnection(localPersonId)) !== null && _a !== void 0 ? _a : this._createConnection(this.channel, localPersonId, this);
        return connection;
    }
    /**@private */
    _createConnection(channel, localPersonId, endpointBot) {
        const localPerson = channel._getPerson(localPersonId);
        // todo fix
        if (!localPerson) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'LocalPerson not found in channel instance.',
            });
        }
        const connection = new connection_1.SFUConnection(localPerson.iceManager, endpointBot._api, channel.id, localPersonId, endpointBot, this._context);
        connection.onClose.once(() => {
            delete this._connections[localPersonId];
        });
        this._connections[localPersonId] = connection;
        return connection;
    }
    /**
     * @description {japanese} StreamのPublicationをForwardingする
     */
    startForwarding(publication, configure = { maxSubscribers: 4 }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'sfuBot not in channel',
                    payload: { status: this.status },
                });
            }
            const relayed = publication;
            log.debug('[start] SfuBotMember startForwarding', {
                publication: relayed.toJSON(),
                configure,
            });
            try {
                const connection = this._getOrCreateConnection(relayed.publisher.id);
                const sender = connection.addSenderConnection(relayed);
                const forwardingId = yield sender.startForwarding(configure);
                let relayingPublication = this.channel._getPublication(forwardingId);
                if (!relayingPublication) {
                    relayingPublication = (yield this.channel.onStreamPublished
                        .watch((e) => e.publication.id === forwardingId, this._context.config.rtcApi.timeout)
                        .catch(() => {
                        throw new common_1.SkyWayError({
                            type: 'timeout',
                            message: 'SfuBotMember onStreamPublished',
                            payload: { forwardingId },
                        });
                    })).publication;
                }
                const forwarding = new forwarding_1.Forwarding(forwardingId, configure, relayed, relayingPublication);
                this.listenStopForwardEvent(forwarding);
                this.onForwardingStarted.emit(forwarding);
                this.onForwardingStateChanged.emit();
                log.debug('[end] SfuBotMember startForwarding', {
                    forwarding: forwarding.toJSON(),
                });
                return forwarding;
            }
            catch (error) {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: '[failed] SfuBotMember startForwarding',
                    payload: { error, publication },
                });
            }
        });
    }
    listenStopForwardEvent(forwarding) {
        const { removeListener } = this.channel.onStreamUnpublished.add((e) => {
            if (e.publication.id === forwarding.id) {
                removeListener();
                forwarding.stop();
                const origin = forwarding.originPublication;
                const connection = this._getConnection(origin.publisherId);
                if (connection) {
                    connection.removeSenderConnection(origin.id);
                }
                this.onForwardingStopped.emit(forwarding);
                this.onForwardingStateChanged.emit();
            }
        });
    }
    /**
     * @description {japanese} Forwardingを停止する
     */
    stopForwarding(forwardingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'sfuBot not in channel',
                    payload: { status: this.status },
                });
            }
            this._api.stopForwarding({
                botId: this.id,
                forwardingId,
            });
            yield this.onForwardingStopped
                .watch((f) => f.id === forwardingId, this._context.config.rtcApi.timeout)
                .catch(() => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'onForwardingStopped',
                });
            });
        });
    }
}
exports.SfuBotMember = SfuBotMember;
SfuBotMember.subtype = 'sfu';
/**
 * @description {japanese} MemberがSfuBotかどうか識別する
 */
SfuBotMember.IsSfuBotMember = (member) => {
    if (member.subtype === SfuBotMember.subtype) {
        return true;
    }
    return false;
};
//# sourceMappingURL=member.js.map