"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Receiver = void 0;
const common_1 = require("@skyway-sdk/common");
const mediasoup_client_1 = require("mediasoup-client");
const ice_1 = require("./ice");
const log = new common_1.Logger('packages/sfu-client/src/connection/receiver.ts');
class Receiver {
    constructor(_iceManager, subscription, _api, _bot, _context, rtpCapabilities) {
        this._iceManager = _iceManager;
        this.subscription = subscription;
        this._api = _api;
        this._bot = _bot;
        this._context = _context;
        this.rtpCapabilities = rtpCapabilities;
        this._device = new mediasoup_client_1.Device();
        this._onConnect = ({ dtlsParameters, }, callback, errback) => __awaiter(this, void 0, void 0, function* () {
            try {
                log.debug('[start] Receiver connect', {
                    subscription: this.subscription,
                });
                yield this._api.connect({
                    botId: this._bot.id,
                    forwardingId: this.subscription.publication.id,
                    transportId: this._transport.id,
                    dtlsParameters,
                });
                log.debug('[end] Receiver connect', { subscription: this.subscription });
                callback();
            }
            catch (error) {
                log.error('Receiver connect failed', {
                    error,
                    subscription: this.subscription,
                });
                errback(error);
            }
        });
    }
    consume() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._device.load({
                routerRtpCapabilities: this.rtpCapabilities,
            });
            log.debug('[start] createConsumer', { subscription: this.subscription });
            const { consumerOptions, transportOptions, producerId } = yield this._api.createConsumer({
                botId: this._bot.id,
                forwardingId: this.subscription.publication.id,
                rtpCapabilities: this._device.rtpCapabilities,
                subscriptionId: this.subscription.id,
            });
            this._setupTransport(transportOptions);
            log.debug('[end] createConsumer');
            const consumer = yield this._transport.consume(Object.assign(Object.assign({}, consumerOptions), { producerId }));
            this._consumer = consumer;
            return { track: consumer.track, codecs: consumer.rtpParameters.codecs };
        });
    }
    _setupTransport(transportOptions) {
        this._transport = this._device.createRecvTransport(Object.assign(Object.assign({}, transportOptions), { iceServers: this._iceManager.iceServers, iceTransportPolicy: this._context.config.rtcConfig.turnPolicy === 'turnOnly'
                ? 'relay'
                : undefined, additionalSettings: this._context.config.rtcConfig }));
        this._transport.on('connect', this._onConnect);
        this._iceConnection = new ice_1.IceConnection(this._transport);
    }
    unconsume() {
        if (!this._consumer) {
            log.debug('unconsume failed, consumer not exist', {
                subscription: this.subscription,
            });
            return;
        }
        this._iceConnection.close();
        this._consumer.close();
        this._consumer = undefined;
        this._transport.close();
    }
    getStats() {
        return this._transport.getStats();
    }
    close() {
        var _a, _b;
        const pc = (_b = (_a = this._transport) === null || _a === void 0 ? void 0 : _a._handler) === null || _b === void 0 ? void 0 : _b._pc;
        // suppress firefox [RTCPeerConnection is gone] Exception
        if (pc === null || pc === void 0 ? void 0 : pc.peerIdentity) {
            pc.peerIdentity.catch(() => { });
        }
        this._transport.close();
    }
    get pc() {
        var _a, _b;
        const pc = (_b = (_a = this._transport) === null || _a === void 0 ? void 0 : _a._handler) === null || _b === void 0 ? void 0 : _b._pc;
        return pc;
    }
}
exports.Receiver = Receiver;
//# sourceMappingURL=receiver.js.map