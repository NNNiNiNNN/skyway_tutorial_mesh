"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sender = void 0;
const common_1 = require("@skyway-sdk/common");
const mediasoup_client_1 = require("mediasoup-client");
const ice_1 = require("./ice");
const log = new common_1.Logger('packages/sfu-client/src/connection/sender.ts');
class Sender {
    constructor(publication, _iceManager, _api, _bot, _context) {
        this.publication = publication;
        this._iceManager = _iceManager;
        this._api = _api;
        this._bot = _bot;
        this._context = _context;
        this._device = new mediasoup_client_1.Device();
        this._disposer = [];
        this._onConnect = ({ dtlsParameters, }, callback, errback) => __awaiter(this, void 0, void 0, function* () {
            try {
                log.debug('[start] Sender connect', { publication: this.publication });
                yield this._api.connect({
                    botId: this._bot.id,
                    forwardingId: this.forwardingId,
                    transportId: this._transport.id,
                    dtlsParameters,
                });
                log.debug('[end] Sender connect', { publication: this.publication });
                callback();
            }
            catch (error) {
                log.error('Sender connect failed', {
                    error,
                    publication: this.publication,
                });
                errback(error);
            }
        });
        this._onProduce = (producerOptions, callback, errback) => __awaiter(this, void 0, void 0, function* () {
            try {
                log.debug('[start] createProducer', { publication: this.publication });
                const id = yield this._api.createProducer({
                    botId: this._bot.id,
                    forwardingId: this.forwardingId,
                    transportId: this._transport.id,
                    producerOptions,
                });
                log.debug('[end] createProducer', {
                    publication: this.publication,
                    id,
                });
                callback({ id });
            }
            catch (error) {
                log.error('[failed] createProducer', {
                    error,
                    publication: this.publication,
                });
                errback(error);
            }
        });
    }
    startForwarding(configure) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.publication.contentType === 'data') {
                throw new common_1.SkyWayError({
                    type: 'invalidParameter',
                    message: 'sfu not support dataStream',
                });
            }
            this._startingForwarding = new common_1.Event();
            log.debug('[start] Sender startForwarding', {
                botId: this._bot.id,
                publicationId: this.publication.id,
                contentType: this.publication.contentType,
                maxSubscribers: configure.maxSubscribers,
            });
            const { routerRtpCapabilities, transportOptions, forwardingId } = yield this._api.startForwarding({
                botId: this._bot.id,
                publicationId: this.publication.id,
                contentType: this.publication.contentType,
                maxSubscribers: configure.maxSubscribers,
            });
            this.forwardingId = forwardingId;
            log.debug('[end] Sender startForwarding', {
                forwardingId,
            });
            yield this._loadDevice(routerRtpCapabilities);
            this._setupTransport(transportOptions);
            this._startingForwarding.emit();
            this._startingForwarding = undefined;
            yield this._produce();
            return forwardingId;
        });
    }
    _loadDevice(routerRtpCapabilities) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._device.load({ routerRtpCapabilities });
        });
    }
    _setupTransport(transportOptions) {
        this._transport = this._device.createSendTransport(Object.assign(Object.assign({}, transportOptions), { iceServers: this._iceManager.iceServers, iceTransportPolicy: this._context.config.rtcConfig.turnPolicy === 'turnOnly'
                ? 'relay'
                : undefined, additionalSettings: this._context.config.rtcConfig }));
        this._transport.on('connect', this._onConnect);
        this._transport.on('produce', this._onProduce);
        this._iceConnection = new ice_1.IceConnection(this._transport);
    }
    _produce() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._startingForwarding) {
                yield this._startingForwarding.asPromise(this._context.config.rtcApi.timeout);
            }
            const stream = this.publication.stream;
            if (!stream) {
                throw new common_1.SkyWayError({
                    type: 'notFound',
                    message: 'publication not have stream',
                });
            }
            this._disposer = [
                ...this._disposer,
                stream._onReplaceTrack.add((track) => __awaiter(this, void 0, void 0, function* () {
                    yield this._replaceTrack(track.clone());
                })).removeListener,
                stream._onMuted.add(() => __awaiter(this, void 0, void 0, function* () {
                    yield this._replaceTrack(stream._mutedTrack.clone());
                })).removeListener,
                stream._onUnmuted.add(() => __awaiter(this, void 0, void 0, function* () {
                    yield this._replaceTrack(stream.track.clone());
                })).removeListener,
            ];
            const track = stream.muted
                ? stream._mutedTrack.clone()
                : stream.track.clone();
            const producerOptions = { track };
            const encodings = this.publication.encodings;
            if (encodings) {
                producerOptions.encodings = encodings;
            }
            const deviceCodecs = (_a = this._device.rtpCapabilities.codecs) !== null && _a !== void 0 ? _a : [];
            const codecMimeType = (_c = (_b = this.publication.codecCapabilities.find((codec) => deviceCodecs
                .map((rtp) => rtp.mimeType.toLowerCase())
                .includes(codec.mimeType.toLowerCase()))) === null || _b === void 0 ? void 0 : _b.mimeType) !== null && _c !== void 0 ? _c : '';
            const codec = deviceCodecs.find((c) => c.mimeType.toLowerCase() === codecMimeType.toLocaleLowerCase());
            if (codec) {
                producerOptions.codec = codec;
            }
            const producer = yield this._transport.produce(producerOptions);
            this._producer = producer;
            yield this._setupEncoding(producer);
        });
    }
    _setupEncoding(producer) {
        return __awaiter(this, void 0, void 0, function* () {
            const encodings = this.publication.encodings;
            const setEncodingParams = (newEncodings) => __awaiter(this, void 0, void 0, function* () {
                const sender = producer.rtpSender;
                const params = sender.getParameters();
                if (params.encodings == undefined) {
                    params.encodings = [];
                }
                params.encodings = newEncodings.map((v, i) => (Object.assign(Object.assign({}, (params.encodings[i] || {})), v)));
                yield sender
                    .setParameters(params)
                    .catch((e) => log.error('setParameters', e));
            });
            this.publication._onEncodingsChanged.add((encodings) => __awaiter(this, void 0, void 0, function* () {
                yield setEncodingParams(encodings);
            }));
            // safariはsLD後にparamterをsetしないと反映されない
            if (encodings.length > 0 &&
                ((0, mediasoup_client_1.detectDevice)() === 'Safari11' || (0, mediasoup_client_1.detectDevice)() === 'Safari12')) {
                yield setEncodingParams(encodings);
            }
        });
    }
    unproduce() {
        if (!this._producer) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'producer not exist',
            });
        }
        this._iceConnection.close();
        this._producer.close();
        this._producer = undefined;
        this._transport.close();
    }
    _replaceTrack(track) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_b = (_a = this._producer) === null || _a === void 0 ? void 0 : _a.replaceTrack) === null || _b === void 0 ? void 0 : _b.call(_a, { track }));
        });
    }
    getStats() {
        return this._transport.getStats();
    }
    close() {
        var _a, _b;
        const pc = (_b = (_a = this._transport) === null || _a === void 0 ? void 0 : _a._handler) === null || _b === void 0 ? void 0 : _b._pc;
        // suppress firefox [RTCPeerConnection is gone] Exception
        if (pc === null || pc === void 0 ? void 0 : pc.peerIdentity) {
            pc.peerIdentity.catch(() => { });
        }
        this._transport.close();
        this._disposer.forEach((d) => d());
        this._disposer = [];
    }
}
exports.Sender = Sender;
//# sourceMappingURL=sender.js.map