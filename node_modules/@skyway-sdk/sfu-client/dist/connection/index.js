"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SFUConnection = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const receiver_1 = require("./receiver");
const sender_1 = require("./sender");
const log = new common_1.Logger('packages/sfu-client/src/connection/index.ts');
class SFUConnection {
    constructor(_iceManager, _api, channelId, localPersonId, remoteMember, _context) {
        this._iceManager = _iceManager;
        this._api = _api;
        this.channelId = channelId;
        this.localPersonId = localPersonId;
        this.remoteMember = remoteMember;
        this._context = _context;
        this.type = 'sfu';
        this.onDisconnect = new common_1.Event();
        this.onClose = new common_1.Event();
        this.closed = false;
        this._receivers = {};
        this._senders = {};
    }
    addSenderConnection(publication) {
        const sender = new sender_1.Sender(publication, this._iceManager, this._api, this.remoteMember, this._context);
        this._senders[publication.id] = sender;
        return sender;
    }
    removeSenderConnection(originPublicationId) {
        log.debug('removeSenderConnection', originPublicationId);
        const sender = this._senders[originPublicationId];
        if (sender) {
            sender.unproduce();
            delete this._senders[originPublicationId];
        }
    }
    startSubscribing(subscription) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.rtpCapabilities) {
                log.debug('[start] getCapabilities');
                this.rtpCapabilities = yield this._api.getCapabilities({
                    botId: this.remoteMember.id,
                    forwardingId: subscription.publication.id,
                });
                log.debug('[end] getCapabilities');
            }
            const receiver = new receiver_1.Receiver(this._iceManager, subscription, this._api, this.remoteMember, this._context, this.rtpCapabilities);
            this._receivers[subscription.id] = receiver;
            const { codecs, track } = yield receiver.consume();
            const [selectedCodec] = codecs;
            // todo fix
            const stream = (0, core_1.createRemoteStream)('', '', track);
            subscription.codec = selectedCodec;
            subscription.stream = stream;
        });
    }
    stopSubscribing(subscription) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = this._receivers[subscription.id];
            if (!connection) {
                throw new common_1.SkyWayError({
                    type: 'notFound',
                    message: 'not exist connection',
                    payload: { subscription },
                });
            }
            connection.unconsume();
            delete this._receivers[subscription.id];
        });
    }
    stopPublishing(publication) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeSenderConnection(publication.id);
        });
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        Object.values(this._senders).forEach((s) => {
            s.close();
        });
        this._senders = {};
        Object.values(this._receivers).forEach((r) => {
            r.close();
        });
        this._receivers = {};
        this.onClose.emit();
    }
    getReceiver(subscriptionId) {
        return this._receivers[subscriptionId];
    }
    getSender(forwardingId) {
        return this._senders[forwardingId];
    }
}
exports.SFUConnection = SFUConnection;
//# sourceMappingURL=index.js.map