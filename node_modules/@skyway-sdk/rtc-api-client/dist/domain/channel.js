"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.channelFactory = exports.ChannelImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const config_1 = require("../config");
const eventObserver_1 = require("../infrastructure/eventObserver");
const log = new common_1.Logger('packages/rtc-api-client/src/domain/channel.ts');
class ChannelImpl {
    constructor(appId, init, eventObserver, apiClient) {
        this.appId = appId;
        this.eventObserver = eventObserver;
        this.apiClient = apiClient;
        this.disposed = false;
        // events
        this._events = new common_1.Events();
        this.onClosed = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMembershipChanged = this._events.make();
        this.onMemberJoined = this._events.make();
        this.onMemberLeft = this._events.make();
        this.onMemberMetadataUpdated = this._events.make();
        this.onPublicationChanged = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationMetadataUpdated = this._events.make();
        this.onSubscriptionChanged = this._events.make();
        this.onStreamSubscribed = this._events.make();
        this.onStreamUnsubscribed = this._events.make();
        this.updateChannelMetadata = (metadata) => new Promise((r, f) => {
            this.apiClient
                .updateChannelMetadata(this.appId, this.id, metadata)
                .catch(f);
            this.onMetadataUpdated
                .watch((e) => e.channel.metadata === metadata)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl updateChannelMetadata',
                payload: { error },
            })));
        });
        this.leave = (channelId, memberId) => new Promise((r, f) => {
            this.apiClient.leave(this.appId, channelId, memberId).catch(f);
            this.onMemberLeft
                .watch((e) => e.member.id === memberId, config_1.Config.get.rtcApi.timeout)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl onMemberLeft',
                payload: { error },
            })));
        });
        this.updateMemberMetadata = (memberId, metadata) => new Promise((r, f) => {
            this.apiClient
                .updateMemberMetadata(this.appId, this.id, memberId, metadata)
                .catch(f);
            this.onMemberMetadataUpdated
                .watch((e) => e.member.id === memberId && e.member.metadata === metadata)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl updateMemberMetadata',
                payload: { error },
            })));
        });
        this.unpublish = (publicationId) => new Promise((r, f) => {
            this.apiClient.unpublish(this.appId, this.id, publicationId).catch(f);
            this.onStreamUnpublished
                .watch((e) => e.publication.id === publicationId)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl unpublish',
                payload: { error },
            })));
        });
        this.updatePublicationMetadata = (publicationId, metadata) => new Promise((r, f) => {
            this.apiClient
                .updatePublicationMetadata(this.appId, this.id, publicationId, metadata)
                .catch(f);
            this.onPublicationMetadataUpdated
                .watch((e) => e.publication.id === publicationId &&
                e.publication.metadata === metadata)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl updatePublicationMetadata',
                payload: { error },
            })));
        });
        this.unsubscribe = (subscriptionId) => new Promise((r, f) => {
            this.apiClient.unsubscribe(this.appId, this.id, subscriptionId).catch(f);
            this.onStreamUnsubscribed
                .watch((e) => e.subscription.id === subscriptionId)
                .then(() => r())
                .catch((error) => f(new common_1.SkyWayError({
                type: 'timeout',
                message: 'ChannelImpl unsubscribe',
                payload: { error },
            })));
        });
        this.id = init.id;
        this.name = init.name;
        this.metadata = init.metadata;
        this.members = init.members;
        this.publications = init.publications;
        this.subscriptions = init.subscriptions;
        this.version = init.version;
        eventObserver.onEvent.add((event) => {
            log.debug('received event: ', event);
            this.version = event.data.channel.version;
            switch (event.type) {
                case 'ChannelDeleted':
                    {
                        this._channelClosed();
                    }
                    break;
                case 'ChannelMetadataUpdated':
                    {
                        this._channelMetadataUpdated(event.data);
                    }
                    break;
                case 'MemberAdded':
                    {
                        this._memberJoined(event.data);
                    }
                    break;
                case 'MemberRemoved':
                    {
                        this._memberLeft(event.data);
                    }
                    break;
                case 'MemberMetadataUpdated':
                    {
                        this._memberMetadataUpdated(event.data);
                    }
                    break;
                case 'StreamPublished':
                    {
                        this._streamPublished(event.data);
                    }
                    break;
                case 'StreamUnpublished':
                    {
                        this._streamUnpublished(event.data);
                    }
                    break;
                case 'PublicationMetadataUpdated':
                    {
                        this._publicationMetadataUpdated(event.data);
                    }
                    break;
                case 'StreamSubscribed':
                    {
                        this._streamSubscribed(event.data);
                    }
                    break;
                case 'StreamUnsubscribed':
                    {
                        this._streamUnsubscribed(event.data);
                    }
                    break;
            }
        });
        apiClient.onClose.once(() => {
            this.dispose();
        });
    }
    getMember(id) {
        return this.members.find((s) => s.id === id);
    }
    addMember(member) {
        const exist = this.getMember(member.id);
        if (exist) {
            return exist;
        }
        this.members.push(member);
        return member;
    }
    deleteMember(id) {
        this.members = this.members.filter((m) => m.id !== id);
    }
    getPublication(id) {
        return this.publications.find((s) => s.id === id);
    }
    addPublication(summary) {
        const exist = this.getPublication(summary.id);
        if (exist) {
            return exist;
        }
        const publication = Object.assign(Object.assign({}, summary), { channelId: this.id, 
            // todo fix
            codecCapabilities: [], 
            // todo fix
            encodings: [] });
        this.publications.push(publication);
        return publication;
    }
    deletePublication(publicationId) {
        this.publications = this.publications.filter((p) => p.id !== publicationId);
    }
    getSubscription(id) {
        return this.subscriptions.find((s) => s.id === id);
    }
    addSubscription(summary) {
        const exist = this.getSubscription(summary.id);
        if (exist) {
            return exist;
        }
        const publication = this.getPublication(summary.publicationId);
        const subscription = Object.assign(Object.assign({}, summary), { channelId: this.id, publisherId: publication.publisherId, contentType: publication.contentType });
        this.subscriptions.push(subscription);
        return subscription;
    }
    deleteSubscription(subscriptionId) {
        this.subscriptions = this.subscriptions.filter((s) => s.id !== subscriptionId);
    }
    _channelClosed() {
        this.onClosed.emit({});
    }
    _channelMetadataUpdated(event) {
        this.metadata = event.channel.metadata;
        this.onMetadataUpdated.emit(event);
    }
    _memberJoined(event) {
        this.addMember(event.member);
        this.onMemberJoined.emit(event);
        this.onMembershipChanged.emit({});
    }
    _memberLeft(event) {
        const member = this.getMember(event.member.id);
        if (!member) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'member not found',
                payload: { event },
            });
        }
        this.deleteMember(member.id);
        this.onMemberLeft.emit({ member });
        this.onMembershipChanged.emit({});
    }
    _memberMetadataUpdated(event) {
        const member = this.getMember(event.member.id);
        if (!member) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'member not found',
                payload: { event },
            });
        }
        member.metadata = event.member.metadata;
        this.onMemberMetadataUpdated.emit(event);
    }
    _streamPublished(incoming) {
        const publication = this.addPublication(incoming.publication);
        const outgoing = Object.assign(Object.assign({}, incoming), { publication });
        this.onStreamPublished.emit(outgoing);
        this.onPublicationChanged.emit({});
    }
    _streamUnpublished(incoming) {
        const publication = this.getPublication(incoming.publication.id);
        if (!publication) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'publication not found',
            });
        }
        this.deletePublication(publication.id);
        const outgoing = Object.assign(Object.assign({}, incoming), { publication });
        this.onStreamUnpublished.emit(outgoing);
        this.onPublicationChanged.emit({});
    }
    _publicationMetadataUpdated(incoming) {
        const publication = this.getPublication(incoming.publication.id);
        if (!publication) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'publication not found',
            });
        }
        publication.metadata = incoming.publication.metadata;
        const outgoing = Object.assign(Object.assign({}, incoming), { publication });
        this.onPublicationMetadataUpdated.emit(outgoing);
    }
    _streamSubscribed(incoming) {
        const subscription = this.addSubscription(incoming.subscription);
        const outgoing = Object.assign(Object.assign({}, incoming), { subscription });
        this.onStreamSubscribed.emit(outgoing);
        this.onSubscriptionChanged.emit({});
    }
    _streamUnsubscribed(incoming) {
        const subscription = this.getSubscription(incoming.subscription.id);
        if (!subscription)
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'subscription not found',
            });
        this.deleteSubscription(subscription.id);
        const outgoing = Object.assign(Object.assign({}, incoming), { subscription });
        this.onStreamUnsubscribed.emit(outgoing);
        this.onSubscriptionChanged.emit({});
    }
    joinChannel(memberInit) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // todo fix
            if (memberInit.type) {
                memberInit.type = (memberInit.type[0].toUpperCase() +
                    memberInit.type.slice(1));
            }
            // todo fix
            if (memberInit.subtype) {
                memberInit.subtype = (memberInit.subtype[0].toUpperCase() +
                    memberInit.subtype.slice(1));
            }
            log.debug('[start] joinChannel', { memberInit });
            const res = yield this.apiClient.join(this.appId, this.id, Object.assign({}, memberInit));
            const member = (_a = this.getMember(res.id)) !== null && _a !== void 0 ? _a : (yield this.onMemberJoined
                .watch((e) => e.member.id === res.id, config_1.Config.get.rtcApi.timeout)
                .catch((error) => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'ChannelImpl onMemberJoined',
                    payload: { res, error, exist: this.getMember(res.id) },
                });
            })).member;
            log.debug('[end] joinChannel', { member });
            return member;
        });
    }
    updateMemberTtl(memberId, ttlSec) {
        return this.apiClient.updateMemberTtl(this.appId, this.id, memberId, ttlSec);
    }
    publish(init) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] apiClient.publish', { init });
            const publicationDto = yield this.apiClient.publish(this.appId, Object.assign(Object.assign({}, init), { channel: this.id }));
            log.debug('[end] apiClient.publish', { publicationDto });
            const exist = this.getPublication(publicationDto.id);
            if (exist) {
                return exist;
            }
            const { publication } = yield this.onStreamPublished
                .watch((e) => e.publication.id === publicationDto.id, config_1.Config.get.rtcApi.timeout)
                .catch((error) => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'ChannelImpl onStreamPublished',
                    payload: {
                        publicationDto,
                        error,
                        exist: this.getPublication(publicationDto.id),
                    },
                });
            });
            return publication;
        });
    }
    subscribe(init) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] apiClient.subscribe', { init });
            const subscriptionDto = yield this.apiClient.subscribe(this.appId, Object.assign(Object.assign({}, init), { channel: this }));
            log.debug('[end] apiClient.subscribe', { subscriptionDto });
            const exist = this.getSubscription(subscriptionDto.id);
            if (exist) {
                return exist;
            }
            const { subscription } = yield this.onStreamSubscribed
                .watch((e) => e.subscription.id === subscriptionDto.id, config_1.Config.get.rtcApi.timeout)
                .catch((error) => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'ChannelImpl onStreamSubscribed',
                    payload: {
                        subscriptionDto,
                        error,
                    },
                });
            });
            return subscription;
        });
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        log.debug('disposed', { id: this.id });
        this.eventObserver.dispose();
        this._events.dispose();
    }
}
exports.ChannelImpl = ChannelImpl;
function channelFactory(appId, rpc, // todo refactor
api, // todo refactor
channelDto) {
    const eventObserver = new eventObserver_1.EventObserverImpl(appId, rpc, channelDto);
    const channel = new ChannelImpl(appId, channelDto, eventObserver, api);
    return channel;
}
exports.channelFactory = channelFactory;
//# sourceMappingURL=channel.js.map