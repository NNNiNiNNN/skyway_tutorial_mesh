"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalPersonImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const config_1 = require("../../config");
const member_1 = require("../../plugin/internal/unknown/member");
const __1 = require("..");
const remoteMember_1 = require("../remoteMember");
const agent_1 = require("./agent");
__exportStar(require("./adapter"), exports);
__exportStar(require("./factory"), exports);
const log = new common_1.Logger('packages/core/src/member/person/local/index.ts');
/**@internal */
class LocalPersonImpl extends __1.MemberImpl {
    /**@private */
    constructor(args) {
        super(args);
        this.args = args;
        this.type = 'person';
        this.subtype = 'person';
        this.side = 'local';
        this.keepaliveIntervalSec = this.args.keepaliveIntervalSec;
        this.iceManager = this.args.iceManager;
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationChanged = this._events.make();
        this.onStreamSubscribed = this._events.make();
        this.onStreamUnsubscribed = this._events.make();
        this.onSubscriptionChanged = this._events.make();
        this._onStreamSubscribeFailed = this._events.make();
        /**@private */
        this._onDisposed = this._events.make();
        /**@private */
        this._disposed = false;
        this._publishingAgent = new agent_1.PublishingAgent(this);
        this._subscribingAgent = new agent_1.SubscribingAgent(this);
        this._messaging = args.messaging;
        this._listenChannelEvent();
        this._listenBeforeUnload();
    }
    static Create(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const person = new LocalPersonImpl(...args);
            yield person._setupTtlTimer().catch((err) => {
                log.error('setupTtlTimer failed', err);
            });
            return person;
        });
    }
    _listenChannelEvent() {
        this.channel.onStreamSubscribed.add(({ subscription }) => __awaiter(this, void 0, void 0, function* () { return this._handleOnStreamSubscribe(subscription); }));
        this.channel.onStreamUnsubscribed.add(({ subscription }) => this._handleOnStreamUnsubscribe(subscription));
        this.channel._onDisposed.once(() => {
            this.dispose();
        });
        this.onLeft.once(() => {
            this.dispose();
        });
    }
    _setupTtlTimer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.keepaliveIntervalSec == null)
                return;
            const updateTtl = () => __awaiter(this, void 0, void 0, function* () {
                const now = Math.floor(Date.now() / 1000);
                this.ttlSec = Math.ceil(now + this.keepaliveIntervalSec + this.keepaliveIntervalSec / 2);
                yield this.channel._updateMemberTtl(this.id, this.ttlSec);
                log.debug('updateTtl', {
                    now,
                    ttlSec: this.ttlSec,
                    keepalive: this.keepaliveIntervalSec,
                    diff: this.ttlSec - now,
                });
            });
            yield updateTtl();
            this.ttlInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield updateTtl().catch(() => {
                    log.error('updateMemberTtl failed', { id: this.id });
                    this.dispose();
                });
            }), this.keepaliveIntervalSec * 1000);
        });
    }
    _listenBeforeUnload() {
        const leave = () => __awaiter(this, void 0, void 0, function* () {
            window.removeEventListener('beforeunload', leave);
            if (this.status !== 'joined') {
                return;
            }
            log.debug('leave by beforeunload');
            yield this.leave();
        });
        window.addEventListener('beforeunload', leave);
    }
    _handleOnStreamSubscribe(subscription) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (subscription.subscriberId === this.id) {
                try {
                    log.debug('[start] startSubscribing', { subscription });
                    yield this._subscribingAgent.startSubscribing(subscription);
                    this.onStreamSubscribed.emit({
                        subscription,
                        stream: subscription.stream,
                    });
                    this.onSubscriptionChanged.emit();
                    log.debug('[end] startSubscribing', { subscription });
                }
                catch (error) {
                    log.warn('[failed] startSubscribing', { subscription, error });
                    this._onStreamSubscribeFailed.emit({ error, subscription });
                }
            }
            if (((_a = subscription.publication) === null || _a === void 0 ? void 0 : _a.publisherId) === this.id) {
                if (subscription.subscriberId === this.id) {
                    throw new common_1.SkyWayError({
                        type: 'forbidden',
                        message: 'can not subscribe own Publication',
                    });
                }
                try {
                    log.debug('[start] startPublishing', { subscription });
                    yield this._publishingAgent.startPublishing(subscription.publication, subscription.subscriber);
                    log.debug('[end] startPublishing', { subscription });
                }
                catch (error) {
                    log.debug('[failed] startPublishing', { subscription, error });
                }
            }
        });
    }
    _handleOnStreamUnsubscribe(subscription) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = subscription.publication) === null || _a === void 0 ? void 0 : _a.publisherId) === this.id) {
                yield this._publishingAgent.stopPublishing(subscription.publication, subscription.subscriber);
            }
            if (subscription.subscriberId === this.id) {
                try {
                    yield this._subscribingAgent.stopSubscribing(subscription);
                    this.onStreamUnsubscribed.emit({ subscription });
                    this.onSubscriptionChanged.emit();
                }
                catch (error) {
                    log.warn('failed to stopSubscribing', { subscription, error });
                }
            }
        });
    }
    publish(stream, options = {}) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'channel stopped',
                });
            }
            const init = {
                metadata: options.metadata,
                publisher: this.id,
                channel: this.channel.id,
                contentType: stream.contentType,
                codecCapabilities: (_a = options.codecCapabilities) !== null && _a !== void 0 ? _a : [],
                encodings: (_b = options.encodings) !== null && _b !== void 0 ? _b : [],
            };
            log.debug('[start] publish', { init });
            try {
                const published = yield this.channel._publish(init);
                const publication = this.channel._addPublication(published);
                publication.stream = stream;
                // todo fix
                publication.codecCapabilities = (_c = options.codecCapabilities) !== null && _c !== void 0 ? _c : [];
                publication.encodings = (_d = options.encodings) !== null && _d !== void 0 ? _d : [];
                this.onStreamPublished.emit({ publication });
                this.onPublicationChanged.emit();
                log.debug('[end] publish', { publication });
                return publication;
            }
            catch (error) {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: '[failed] publish',
                    payload: { error, init },
                });
            }
        });
    }
    unpublish(publicationId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({ type: 'forbidden', message: 'channel stopped' });
            }
            const publication = this.channel._getPublication(publicationId);
            if (!publication) {
                throw new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'can not unpublish not exist publication',
                    payload: { publicationId },
                });
            }
            log.debug('[start] unpublish', { publication });
            yield this.channel._unpublish(publicationId);
            publication.subscriptions
                .map((s) => s.subscriber)
                .forEach((s) => {
                if ((0, remoteMember_1.isRemoteMember)(s)) {
                    this._publishingAgent.stopPublishing(publication, s);
                }
            });
            this.onStreamUnpublished.emit({ publication });
            this.onPublicationChanged.emit();
            log.debug('[end] unpublish', { publication });
        });
    }
    subscribe(publicationId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({ type: 'forbidden', message: 'channel stopped' });
            }
            const publication = this.channel._getPublication(publicationId);
            this._validatePublicationForSubscribe(publication);
            log.debug('[start] subscribe', { publication });
            let subscribing = true;
            try {
                const subscriptionDto = yield this.channel._subscribe(this.id, publicationId);
                const subscription = this.channel._addSubscription(subscriptionDto);
                if (!subscription.stream) {
                    yield Promise.race([
                        this.onStreamSubscribed
                            .watch(({ subscription }) => subscription.publication.id === publicationId, config_1.SkyWayConfig.get.rtcApi.timeout)
                            .catch((e) => __awaiter(this, void 0, void 0, function* () {
                            if (!subscribing) {
                                return;
                            }
                            if (this.channel._getMember(subscriptionDto.publisherId)) {
                                log.warn('[start] fallback subscription', { subscriptionDto });
                                this.unsubscribe(subscriptionDto.id)
                                    .then(() => {
                                    log.warn('[end] fallback subscription', {
                                        subscriptionDto,
                                    });
                                })
                                    .catch((error) => {
                                    log.warn('[failed] fallback subscription', {
                                        subscriptionDto,
                                        error,
                                    });
                                });
                            }
                            throw new common_1.SkyWayError({
                                type: 'timeout',
                                message: 'failed to subscribe publication. maybe publisher already left room',
                                payload: { error: e, stream: !!subscription.stream },
                            });
                        })),
                        this.channel.onMemberLeft
                            .watch((e) => e.member.id === publication.publisherId, config_1.SkyWayConfig.get.rtcApi.timeout + 5000)
                            .then(() => {
                            if (subscribing) {
                                throw new common_1.SkyWayError({
                                    type: 'deleted',
                                    message: 'failed to subscribe publication. publisher already left room',
                                });
                            }
                        })
                            .catch(() => { }),
                        this._onStreamSubscribeFailed
                            .watch((e) => e.subscription.publication.id === publication.id, config_1.SkyWayConfig.get.rtcApi.timeout)
                            .then((error) => {
                            if (subscribing) {
                                throw new common_1.SkyWayError({
                                    type: 'internalError',
                                    message: 'subscribe _onStreamSubscribeFailed',
                                    payload: { error },
                                });
                            }
                        })
                            .catch(() => { }),
                    ]);
                }
                subscribing = false;
                log.debug('[end] subscribe', { subscription });
                return {
                    subscription: subscription,
                    stream: subscription.stream,
                };
            }
            catch (error) {
                subscribing = false;
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: '[failed] subscribe',
                    payload: { error, publication },
                });
            }
        });
    }
    _validatePublicationForSubscribe(publication) {
        if (publication == undefined) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'can not subscribe not exist publication',
                payload: { publication, memberId: this.id },
            });
        }
        if (publication.publisher.id === this.id) {
            throw new common_1.SkyWayError({
                type: 'forbidden',
                message: 'can not subscribe own Publication',
                payload: { publication, memberId: this.id },
            });
        }
        if (publication.publisher instanceof member_1.UnknownMemberImpl) {
            throw new common_1.SkyWayError({
                type: 'forbidden',
                message: `can't subscribe publication. publisher subtype ${publication.publisher.subtype} plugin is not registered`,
                payload: { publication, memberId: this.id },
            });
        }
        if (this.subscriptions.find((s) => s.publication.id === publication.id)) {
            throw new common_1.SkyWayError({
                type: 'forbidden',
                message: 'can not subscribe already subscribed Publication',
                payload: { publication, memberId: this.id },
            });
        }
    }
    unsubscribe(subscriptionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== 'joined') {
                throw new common_1.SkyWayError({ type: 'forbidden', message: 'channel stopped' });
            }
            const subscription = this.subscriptions.find((s) => s.id === subscriptionId);
            if (!subscription) {
                throw new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'can not unsubscribe not exist subscription',
                    payload: { subscriptionId },
                });
            }
            log.debug('[start] unsubscribe', { subscription });
            yield this.channel._unsubscribe(subscriptionId);
            log.debug('[end] unsubscribe', { subscription });
        });
    }
    getConnections() {
        const connections = this.channel.members.map((m) => m._getConnection(this.id));
        const active = connections.filter((c) => (c === null || c === void 0 ? void 0 : c.closed) === false);
        return active;
    }
    leave() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.channel.leave(this);
        });
    }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        log.debug('disposed', { id: this.id });
        clearInterval(this.ttlInterval);
        this._messaging.disconnect();
        this.getConnections().forEach((c) => c.close());
        this._onDisposed.emit();
        this._events.dispose();
    }
}
exports.LocalPersonImpl = LocalPersonImpl;
//# sourceMappingURL=index.js.map