import { Member } from '../../../..';
import { IceManager } from '../../../../external/ice';
import { PublicationImpl } from '../../../../publication';
import { P2PMessage, P2PMessenger } from './messenger';
import { Peer } from './peer';
export declare class Sender extends Peer {
    publications: {
        [publicationId: string]: PublicationImpl;
    };
    transceivers: {
        [publicationId: string]: RTCRtpTransceiver;
    };
    datachannels: {
        [publicationId: string]: RTCDataChannel;
    };
    private _pendingPublications;
    private _isNegotiating;
    private readonly promiseQueue;
    private disposer;
    constructor(iceManager: IceManager, messenger: P2PMessenger, memberId: string, endpoint: Pick<Member, 'id' | 'name'>);
    get hasMedia(): boolean;
    add(publication: PublicationImpl): Promise<void>;
    private applyCodecCapabilities;
    remove(publicationId: string): Promise<void>;
    private _replaceTrack;
    private _setParam;
    private _handleReceiverAnswer;
    private _resolvePendingSender;
    close(): void;
}
export interface SenderProduceMessage extends P2PMessage {
    type: 'p2pMessage';
    kind: 'senderProduceMessage';
    payload: {
        sdp: RTCSessionDescriptionInit;
        publicationId: string;
        info: {
            publicationId: string;
            streamId: string;
            label: string;
            mid?: string | null;
        };
    };
}
export interface SenderUnproduceMessage extends P2PMessage {
    type: 'p2pMessage';
    kind: 'senderUnproduceMessage';
    payload: {
        sdp: RTCSessionDescriptionInit;
        publicationId: string;
    };
}
//# sourceMappingURL=sender.d.ts.map