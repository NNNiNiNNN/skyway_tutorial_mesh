"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sender = void 0;
const common_1 = require("@skyway-sdk/common");
const sdpTransform = __importStar(require("sdp-transform"));
const datachannel_1 = require("./datachannel");
const peer_1 = require("./peer");
const log = new common_1.Logger('packages/core/src/plugin/internal/person/connection/sender.ts');
class Sender extends peer_1.Peer {
    constructor(iceManager, messenger, memberId, endpoint) {
        super(iceManager, messenger, memberId, endpoint, 'sender');
        this.publications = {};
        this.transceivers = {};
        this.datachannels = {};
        this._pendingPublications = [];
        this._isNegotiating = false;
        this.promiseQueue = new common_1.PromiseQueue();
        this.disposer = [];
        this._setParam = (transceiver, sendEncoding) => __awaiter(this, void 0, void 0, function* () {
            const params = transceiver.sender.getParameters();
            if (params.encodings == undefined || params.encodings.length === 0) {
                params.encodings = [{}];
            }
            params.encodings = [Object.assign(Object.assign({}, params.encodings[0]), sendEncoding)];
            yield transceiver.sender.setParameters(params).catch((e) => log.error('setPrams', {
                e,
                localPersonId: this.localPersonId,
                endpointId: this.endpoint.id,
            }));
        });
        this.messenger.onIndicated.add(({ src, data }) => __awaiter(this, void 0, void 0, function* () {
            if (!(src.id === endpoint.id && src.name === endpoint.name))
                return;
            const message = data;
            switch (message.kind) {
                case 'receiverAnswerMessage':
                    {
                        this.promiseQueue
                            .push(() => this._handleReceiverAnswer(message.payload))
                            .catch((err) => log.error('handle receiverAnswerMessage', {
                            localPersonId: this.localPersonId,
                            endpointId: this.endpoint.id,
                            err,
                        }));
                    }
                    break;
                case 'iceCandidateMessage':
                    {
                        const { role, candidate } = message.payload;
                        if (role === 'receiver') {
                            this.handleCandidate(candidate).catch((err) => log.warn('handle iceCandidateMessage', {
                                localPersonId: this.localPersonId,
                                endpointId: this.endpoint.id,
                                err,
                            }));
                        }
                    }
                    break;
            }
        }));
    }
    get hasMedia() {
        if (Object.values(this.datachannels).length > 0 ||
            Object.values(this.transceivers).length > 0) {
            return true;
        }
        return false;
    }
    add(publication) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isNegotiating || this.pc.signalingState !== 'stable') {
                this._pendingPublications.push(publication);
                log.debug('isNegotiating', {
                    publication,
                    isNegotiating: this._isNegotiating,
                    signalingState: this.pc.signalingState,
                });
                return;
            }
            this._isNegotiating = true;
            log.debug('add publication', { publication });
            this.publications[publication.id] = publication;
            const stream = publication.stream;
            if (!stream) {
                throw new common_1.SkyWayError({ type: 'notFound', message: 'stream not found' });
            }
            if (stream.contentType === 'data') {
                const dc = this.pc.createDataChannel(new datachannel_1.DataChannelNegotiationLabel(publication.id, stream.id, stream.label).toLabel(), stream._options);
                this.disposer = [
                    ...this.disposer,
                    stream._onWriteData.add((data) => {
                        if (dc.readyState !== 'open')
                            return;
                        dc.send(data);
                    }).removeListener,
                ];
                this.datachannels[publication.id] = dc;
            }
            else {
                this.disposer = [
                    ...this.disposer,
                    stream._onReplaceTrack.add((track) => __awaiter(this, void 0, void 0, function* () {
                        yield this._replaceTrack(publication.id, track.clone());
                    })).removeListener,
                    stream._onMuted.add(() => __awaiter(this, void 0, void 0, function* () {
                        yield this._replaceTrack(publication.id, stream._mutedTrack.clone());
                    })).removeListener,
                    stream._onUnmuted.add(() => __awaiter(this, void 0, void 0, function* () {
                        yield this._replaceTrack(publication.id, stream.track.clone());
                    })).removeListener,
                ];
                const track = stream.muted
                    ? stream._mutedTrack.clone()
                    : stream.track.clone(); // botとtrackを共有するとsendEncodingの書き換えで問題が起きる
                const transceiver = this.pc.addTransceiver(track, {
                    direction: 'sendonly',
                });
                publication._onEncodingsChanged.add((encodings) => __awaiter(this, void 0, void 0, function* () {
                    yield this._setParam(transceiver, encodings[0]); // p2pなら長さは常に1
                }));
                this.transceivers[publication.id] = transceiver;
            }
            const offer = yield this.pc.createOffer().catch((err) => {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: "can't create offer",
                    payload: err,
                });
            });
            yield this.pc.setLocalDescription(offer);
            const sdpObject = sdpTransform.parse(this.pc.localDescription.sdp);
            if (publication.contentType !== 'data' &&
                ((_a = publication.codecCapabilities) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                const transceiver = this.transceivers[publication.id];
                const mid = transceiver.mid;
                if (mid == undefined) {
                    throw new common_1.SkyWayError({
                        type: 'notFound',
                        message: 'transceiver not have mid',
                    });
                }
                this.applyCodecCapabilities((_b = publication.codecCapabilities) !== null && _b !== void 0 ? _b : [], mid, sdpObject);
                const offerSdp = sdpTransform.write(sdpObject);
                yield this.pc.setLocalDescription({ type: 'offer', sdp: offerSdp });
            }
            const message = {
                type: 'p2pMessage',
                kind: 'senderProduceMessage',
                payload: {
                    sdp: this.pc.localDescription,
                    publicationId: publication.id,
                    info: {
                        publicationId: publication.id,
                        streamId: stream.id,
                        label: stream.label,
                    },
                },
            };
            if (publication.contentType !== 'data') {
                const transceiver = this.transceivers[publication.id];
                if (((_c = publication.encodings) === null || _c === void 0 ? void 0 : _c.length) > 0) {
                    yield this._setParam(transceiver, publication.encodings[0]);
                }
                const mid = transceiver.mid;
                if (mid == undefined) {
                    throw new common_1.SkyWayError({
                        type: 'parameterMissing',
                        message: 'mid undefined',
                        payload: {
                            mid: transceiver.mid,
                            publication,
                            localPersonId: this.localPersonId,
                            endpointId: this.endpoint.id,
                        },
                    });
                }
                message.payload.info.mid = mid;
            }
            yield this.messenger.indicate(this.endpoint, message).catch((error) => log.error('in remote error :', {
                localPersonId: this.localPersonId,
                endpointId: this.endpoint.id,
                error,
            }));
        });
    }
    applyCodecCapabilities(codecCapabilities, mid, sdpObject) {
        const preferCodecNames = codecCapabilities.map((c) => {
            if (!c.mimeType.includes('/')) {
                throw new common_1.SkyWayError({
                    type: 'invalidParameter',
                    message: 'invalid mimeType format',
                    payload: codecCapabilities,
                });
            }
            const [, codecName] = c.mimeType.split('/');
            if (!codecName) {
                throw new common_1.SkyWayError({
                    type: 'invalidParameter',
                    message: 'codecName not found in mimeType',
                    payload: codecCapabilities,
                });
            }
            return codecName.toLowerCase();
        });
        const media = sdpObject.media.find((m) => { var _a; return ((_a = m.mid) === null || _a === void 0 ? void 0 : _a.toString()) === mid; });
        if (!media) {
            throw new common_1.SkyWayError({
                type: 'notFound',
                message: 'media not found',
            });
        }
        const preferCodecs = media.rtp.filter((rtp) => {
            const [codecName] = rtp.codec.split('/');
            if (preferCodecNames.includes(codecName.toLowerCase())) {
                return true;
            }
            return false;
        });
        const sorted = [
            ...preferCodecs,
            ...media.rtp.filter((rtp) => !preferCodecNames.includes(rtp.codec.toLowerCase())),
        ];
        media.payloads = sorted.map((rtp) => rtp.payload.toString()).join(' ');
    }
    remove(publicationId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isNegotiating || this.pc.signalingState !== 'stable') {
                this._pendingPublications.push(publicationId);
                log.debug('isNegotiating', {
                    publicationId,
                    _isNegotiating: this._isNegotiating,
                    signalingState: this.pc.signalingState,
                });
                return;
            }
            this._isNegotiating = true;
            const publication = this.publications[publicationId];
            if (!publication) {
                log.warn('publication not found', { publicationId });
                return;
            }
            delete this.publications[publicationId];
            const stream = publication.stream;
            if (!stream) {
                throw new common_1.SkyWayError({
                    type: 'notFound',
                    message: 'publication not have stream',
                    payload: publication,
                });
            }
            if (stream.contentType === 'data') {
                const dc = this.datachannels[publicationId];
                dc.close();
                delete this.datachannels[publicationId];
            }
            else {
                const transceiver = this.transceivers[publicationId];
                transceiver.stop();
                delete this.transceivers[publicationId];
            }
            const offer = yield this.pc.createOffer().catch((err) => {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: "can't create offer",
                    payload: err,
                });
            });
            yield this.pc.setLocalDescription(offer);
            const message = {
                type: 'p2pMessage',
                kind: 'senderUnproduceMessage',
                payload: { sdp: this.pc.localDescription, publicationId },
            };
            yield this.messenger.indicate(this.endpoint, message).catch((error) => log.error('in remote error :', {
                localPersonId: this.localPersonId,
                endpointId: this.endpoint.id,
                error,
            }));
        });
    }
    _replaceTrack(publicationId, track) {
        return __awaiter(this, void 0, void 0, function* () {
            const transceiver = this.transceivers[publicationId];
            if (!transceiver) {
                log.warn("can't replace track, transceiver not found", { publicationId });
                return;
            }
            yield transceiver.sender.replaceTrack(track);
        });
    }
    _handleReceiverAnswer({ sdp, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pc.signalingState === 'closed') {
                return;
            }
            log.debug('_handleReceiverAnswer');
            yield this.pc
                .setRemoteDescription(new RTCSessionDescription(sdp))
                .catch((err) => {
                log.error('sRD failed', {
                    localPersonId: this.localPersonId,
                    endpointId: this.endpoint.id,
                    sdp,
                });
                throw err;
            });
            yield this.resolveCandidates();
            yield this.waitForState('stable');
            this._isNegotiating = false;
            yield this._resolvePendingSender();
        });
    }
    _resolvePendingSender() {
        return __awaiter(this, void 0, void 0, function* () {
            const publication = this._pendingPublications.shift();
            if (!publication)
                return;
            log.debug('resolve pending sender', { publication });
            if (typeof publication === 'string') {
                yield this.remove(publication);
            }
            else {
                yield this.add(publication);
            }
        });
    }
    close() {
        log.debug('close sender', {
            localPersonId: this.localPersonId,
            endpointId: this.endpoint.id,
        });
        this.unSetPeerConnectionListener();
        this.disposer.forEach((d) => d());
        this.disposer = [];
        this.pc.close();
    }
}
exports.Sender = Sender;
//# sourceMappingURL=sender.js.map