"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.P2PMessenger = void 0;
const common_1 = require("@skyway-sdk/common");
const config_1 = require("../../../../config");
class P2PMessenger {
    constructor(messaging) {
        this.messaging = messaging;
        this.onIndicated = new common_1.Event();
        this.indicateChunkedMessageBuffer = {};
        this.indicateVersion = 0;
        this.indicate = (target, message) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const id = (this.indicateVersion++).toString();
            const payload = JSON.stringify(message.payload);
            // chunking message
            if (payload.length > 10 * 1024) {
                const split = (_a = payload.match(/.{1,10240}/g)) !== null && _a !== void 0 ? _a : [];
                let offset = 0;
                for (const chunk of split) {
                    const chunkMessage = {
                        type: message.type,
                        kind: message.kind,
                        length: split.length - 1,
                        offset: offset++,
                        chunk,
                        id,
                    };
                    yield this.messaging
                        .indicate({ id: target.id, name: target.name }, chunkMessage, config_1.SkyWayConfig.get.rtcConfig.timeout)
                        .catch((e) => {
                        throw new common_1.SkyWayError({
                            type: 'internalError',
                            message: 'indicate failed',
                            payload: e,
                        });
                    });
                }
            }
            else {
                const chunkMessage = {
                    type: message.type,
                    kind: message.kind,
                    length: 0,
                    offset: 0,
                    chunk: payload,
                    id,
                };
                yield this.messaging
                    .indicate({ id: target.id, name: target.name }, chunkMessage, 30)
                    .catch((e) => {
                    throw new common_1.SkyWayError({
                        type: 'internalError',
                        message: 'indicate failed',
                        payload: e,
                    });
                });
            }
        });
        messaging.onIndicated.addListener(({ src, data }) => {
            var _a;
            if (data.type !== 'p2pMessage')
                return;
            const messageChunk = data;
            const { type, kind, chunk, length, offset, id: messageId } = messageChunk;
            if (length === 0) {
                this.onIndicated.emit({
                    src,
                    data: { type, kind, payload: JSON.parse(chunk) },
                });
            }
            else {
                this.indicateChunkedMessageBuffer[messageId] = [
                    ...((_a = this.indicateChunkedMessageBuffer[messageId]) !== null && _a !== void 0 ? _a : []),
                    messageChunk.chunk,
                ];
                if (length === offset) {
                    const message = this.indicateChunkedMessageBuffer[messageId].join('');
                    delete this.indicateChunkedMessageBuffer[messageId];
                    this.onIndicated.emit({
                        src,
                        data: { type, kind, payload: JSON.parse(message) },
                    });
                }
            }
        });
    }
}
exports.P2PMessenger = P2PMessenger;
const p2pMessageKinds = [
    'senderProduceMessage',
    'senderUnproduceMessage',
    'receiverAnswerMessage',
    'iceCandidateMessage',
];
//# sourceMappingURL=messenger.js.map