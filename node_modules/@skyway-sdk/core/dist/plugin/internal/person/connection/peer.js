"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Peer = void 0;
const common_1 = require("@skyway-sdk/common");
const config_1 = require("../../../../config");
const log = new common_1.Logger('src/core/dataPlane/peerConnection/peer.ts');
class Peer {
    constructor(_iceManager, messenger, localPersonId, endpoint, role) {
        var _a;
        this._iceManager = _iceManager;
        this.messenger = messenger;
        this.localPersonId = localPersonId;
        this.endpoint = endpoint;
        this.role = role;
        this._pendingCandidates = [];
        this.pc = new RTCPeerConnection(Object.assign(Object.assign({}, config_1.SkyWayConfig.get.rtcConfig), { iceTransportPolicy: config_1.SkyWayConfig.get.rtcConfig.turnPolicy === 'turnOnly'
                ? 'relay'
                : undefined, iceServers: this._iceManager.iceServers }));
        this.onSignalingStateChanged = new common_1.Event();
        this.onConnectionStateChanged = new common_1.Event();
        this.onDisconnect = new common_1.Event();
        this.connected = false;
        this.disconnected = false;
        this._onICECandidate = (ev) => __awaiter(this, void 0, void 0, function* () {
            if (ev.candidate == null || this.pc.connectionState === 'closed')
                return;
            const message = {
                type: 'p2pMessage',
                kind: 'iceCandidateMessage',
                payload: {
                    candidate: ev.candidate,
                    role: this.role,
                },
            };
            this.messenger
                .indicate(this.endpoint, message)
                .catch((e) => log.error('failed to send candidate', e));
            log.debug(`[${this.localPersonId}] send candidate`);
        });
        this._onConnectionStateChange = () => __awaiter(this, void 0, void 0, function* () {
            log.debug('_onConnectionStateChange', this.localPersonId, this.pc.iceConnectionState);
            switch (this.pc.iceConnectionState) {
                case 'connected':
                    this.connected = true;
                    this._pendingCandidates = [];
                    break;
                case 'failed':
                    log.warn('ice failed', {
                        localPersonId: this.localPersonId,
                        endpointId: this.endpoint.id,
                    });
                    break;
                case 'disconnected':
                    // ネットワークの揺れを無視
                    yield new Promise((r) => setTimeout(r, 5000));
                    if (!['disconnected', 'failed'].includes(this.pc.iceConnectionState) ||
                        this.pc.connectionState === 'closed') {
                        return;
                    }
                    log.warn('ice disconnected', {
                        localPersonId: this.localPersonId,
                        endpointId: this.endpoint.id,
                    });
                    break;
            }
            this.onConnectionStateChanged.emit(this.pc.iceConnectionState);
        });
        this.waitForState = (state, timeout = 10000) => __awaiter(this, void 0, void 0, function* () {
            if (this.pc.signalingState === state)
                return;
            yield this.onSignalingStateChanged
                .watch(() => this.pc.signalingState === state, timeout)
                .catch((err) => log.warn('peerConnection state timeout', err));
        });
        this.setPeerConnectionListener();
        // suppress firefox [RTCPeerConnection is gone] Exception
        const peerIdentity = (_a = this.pc) === null || _a === void 0 ? void 0 : _a.peerIdentity;
        if (peerIdentity) {
            peerIdentity.catch((err) => {
                log.debug('firefox peerIdentity', err);
            });
        }
    }
    setPeerConnectionListener() {
        this.pc.onicecandidate = this._onICECandidate;
        this.pc.onconnectionstatechange = this._onConnectionStateChange;
        this.pc.onsignalingstatechange = () => this.onSignalingStateChanged.emit(this.pc.signalingState);
    }
    unSetPeerConnectionListener() {
        this.pc.onicecandidate = null;
        this.pc.onconnectionstatechange = null;
        this.pc.onsignalingstatechange = null;
    }
    handleCandidate(candidate) {
        return __awaiter(this, void 0, void 0, function* () {
            this._pendingCandidates.push(candidate);
            if (this.pc.remoteDescription) {
                yield this.resolveCandidates();
            }
        });
    }
    resolveCandidates() {
        return __awaiter(this, void 0, void 0, function* () {
            const candidates = [...this._pendingCandidates];
            this._pendingCandidates = [];
            yield Promise.all(candidates.map((candidate) => {
                if (this.pc.signalingState === 'closed')
                    return;
                log.debug('addIcecandidate', candidate);
                this.pc.addIceCandidate(candidate).catch((err) => {
                    log.warn('failed to add ice candidate', {
                        localPersonId: this.localPersonId,
                        endpointId: this.endpoint.id,
                        err,
                    });
                });
            }));
        });
    }
}
exports.Peer = Peer;
//# sourceMappingURL=peer.js.map