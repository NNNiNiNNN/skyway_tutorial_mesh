"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkyWayChannel = exports.SkyWayChannelImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const common_2 = require("@skyway-sdk/common");
const __1 = require("..");
const config_1 = require("../config");
const factory_1 = require("../publication/factory");
const factory_2 = require("../subscription/factory");
const log = new common_1.Logger('packages/core/src/channel/index.ts');
/**@internal */
class SkyWayChannelImpl {
    constructor(_context, 
    /**@private */
    _channelImpl) {
        this._context = _context;
        this._channelImpl = _channelImpl;
        this.id = this._channelImpl.id;
        this.name = this._channelImpl.name;
        this.appId = this._context.appId;
        this._status = 'created';
        this._api = this._context._api;
        this.disposed = false;
        this._members = {};
        /**@private */
        this._getMember = (id) => this._members[id];
        this._persons = {};
        /**@private */
        this._getPerson = (id) => this._persons[id];
        this._publications = {};
        /**@private */
        this._getPublication = (id) => this._publications[id];
        this._subscriptions = {};
        /**@private */
        this._getSubscription = (id) => this._subscriptions[id];
        // events
        this._events = new common_2.Events();
        this.onClosed = this._events.make();
        this.onMetadataUpdated = this._events.make();
        this.onMembershipChanged = this._events.make();
        this.onMemberJoined = this._events.make();
        this.onMemberLeft = this._events.make();
        this.onMemberMetadataUpdated = this._events.make();
        this.onPublicationChanged = this._events.make();
        this.onStreamPublished = this._events.make();
        this.onStreamUnpublished = this._events.make();
        this.onPublicationMetadataUpdated = this._events.make();
        this.onSubscriptionChanged = this._events.make();
        this.onStreamSubscribed = this._events.make();
        this.onStreamUnsubscribed = this._events.make();
        /**@private */
        this._onDisposed = this._events.make();
        this.leave = (member) => __awaiter(this, void 0, void 0, function* () { return this._channelImpl.leave(this.id, member.id); });
        this.updateMetadata = (metadata) => this._channelImpl.updateChannelMetadata(metadata);
        this.close = () => new Promise((r, f) => __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] close channel', { id: this.id });
            this._api.deleteChannel(this.id).catch((e) => {
                f(e);
            });
            try {
                yield this.onClosed.asPromise(config_1.SkyWayConfig.get.rtcApi.timeout);
                log.debug('[end] close channel', { id: this.id });
            }
            catch (error) {
                f(error);
                log.error('[failed] close channel', { id: this.id, error });
            }
            this._status = 'closed';
            r();
        }));
        /**@private */
        this._updateMemberTtl = (memberId, ttlSec) => this._channelImpl.updateMemberTtl(memberId, ttlSec);
        /**@private */
        this._updateMemberMetadata = (memberId, metadata) => this._channelImpl.updateMemberMetadata(memberId, metadata);
        /**@private */
        this._publish = (init) => this._channelImpl.publish(init);
        /**@private */
        this._unpublish = (publicationId) => __awaiter(this, void 0, void 0, function* () { return this._channelImpl.unpublish(publicationId); });
        /**@private */
        this._subscribe = (subscriberId, publicationId) => {
            const publication = this._getPublication(publicationId);
            const subscriber = this._getMember(subscriberId);
            if (subscriber == undefined) {
                throw new common_2.SkyWayError({
                    type: 'notFound',
                    message: 'subscriber not found',
                    payload: { subscriberId, publicationId },
                });
            }
            return this._channelImpl.subscribe({
                publication: publication.toJSON(),
                subscriber: subscriber.toJSON(),
            });
        };
        /**@private */
        this._unsubscribe = (subscriptionId) => __awaiter(this, void 0, void 0, function* () {
            if (!this._getSubscription(subscriptionId)) {
                throw new common_2.SkyWayError({
                    type: 'forbidden',
                    message: "can't unsubscribe not exist subscription",
                    payload: { subscriptionId },
                });
            }
            yield this._channelImpl.unsubscribe(subscriptionId).catch((e) => {
                throw e;
            });
        });
        /**@private */
        this._updatePublicationMetadata = (publicationId, metadata) => this._channelImpl.updatePublicationMetadata(publicationId, metadata);
        this._setupPropertiesFromChannel();
        this._setupListenChannelEvent();
        this._status = 'opened';
        _context._onDisposed.once(() => {
            this.dispose();
        });
        log.debug('channel spawned', this.toJSON());
    }
    _addMember(memberDto) {
        const exist = this._getMember(memberDto.id);
        if (exist) {
            return exist;
        }
        const member = this._context._createRemoteMember(this, memberDto);
        this._members[member.id] = member;
        return member;
    }
    _removeMember(memberId) {
        delete this._members[memberId];
    }
    _addPerson(member) {
        this._persons[member.id] = member;
    }
    _removePerson(memberId) {
        delete this._persons[memberId];
    }
    /**@private */
    _addPublication(p) {
        const exist = this._getPublication(p.id);
        if (exist) {
            return exist;
        }
        const publication = (0, factory_1.createPublication)(this, p);
        this._publications[p.id] = publication;
        return publication;
    }
    _removePublication(publicationId) {
        delete this._publications[publicationId];
    }
    /**@private */
    _addSubscription(s) {
        const exist = this._getSubscription(s.id);
        if (exist) {
            return exist;
        }
        const subscription = (0, factory_2.createSubscription)(this, s);
        this._subscriptions[s.id] = subscription;
        return subscription;
    }
    _removeSubscription(subscriptionId) {
        delete this._subscriptions[subscriptionId];
    }
    get members() {
        return Object.values(this._members);
    }
    get persons() {
        return Object.values(this._persons);
    }
    get bots() {
        return this.members.filter((m) => m.type === 'bot');
    }
    get publications() {
        return Object.values(this._publications);
    }
    get subscriptions() {
        return Object.values(this._subscriptions);
    }
    get metadata() {
        return this._channelImpl.metadata;
    }
    get status() {
        return this._status;
    }
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            appId: this.appId,
            metadata: this.metadata,
            members: this.members,
            publications: this.publications,
            subscriptions: this.subscriptions,
        };
    }
    _setupPropertiesFromChannel() {
        this._channelImpl.members.forEach((memberDto) => {
            this._addMember(memberDto);
        });
        this._channelImpl.publications.forEach((publicationDto) => {
            this._addPublication(publicationDto);
        });
        this._channelImpl.subscriptions.forEach((subscriptionDto) => {
            this._addSubscription(subscriptionDto);
        });
    }
    _setupListenChannelEvent() {
        this._channelImpl.onClosed.add(() => this._handleOnChannelClose());
        this._channelImpl.onMetadataUpdated.add(({ channel }) => this._handleOnChannelMetadataUpdate(channel.metadata));
        this._channelImpl.onMemberJoined.add(({ member }) => {
            this._handleOnMemberJoin(member);
        });
        this._channelImpl.onMemberLeft.add(({ member }) => {
            this._handleOnMemberLeft(member);
        });
        this._channelImpl.onMembershipChanged.pipe(this.onMembershipChanged);
        this._channelImpl.onMemberMetadataUpdated.add(({ member }) => {
            this._handleOnMemberMetadataUpdate(member, member.metadata);
        });
        this._channelImpl.onStreamPublished.add(({ publication }) => {
            this._handleOnStreamPublish(publication);
        });
        this._channelImpl.onStreamUnpublished.add(({ publication }) => {
            this._handleOnStreamUnpublish(publication);
        });
        this._channelImpl.onPublicationChanged.pipe(this.onPublicationChanged);
        this._channelImpl.onPublicationMetadataUpdated.add(({ publication }) => {
            this._handleOnStreamMetadataUpdate(publication, publication.metadata);
        });
        this._channelImpl.onStreamSubscribed.add(({ subscription }) => {
            this._handleOnStreamSubscribe(subscription);
        });
        this._channelImpl.onStreamUnsubscribed.add(({ subscription }) => {
            this._handleOnStreamUnsubscribe(subscription);
        });
        this._channelImpl.onSubscriptionChanged.pipe(this.onSubscriptionChanged);
    }
    _handleOnChannelClose() {
        this.onClosed.emit({});
        this.dispose();
    }
    _handleOnChannelMetadataUpdate(metadata) {
        this.onMetadataUpdated.emit({ metadata });
    }
    _handleOnMemberJoin(memberDto) {
        const member = this._addMember(memberDto);
        this.onMemberJoined.emit({ member });
    }
    _handleOnMemberLeft(memberDto) {
        const member = this._getMember(memberDto.id);
        this._removeMember(member.id);
        member._left();
        const person = this._getPerson(memberDto.id);
        if (person) {
            this._removePerson(member.id);
            person._left();
        }
        this.onMemberLeft.emit({ member });
    }
    _handleOnMemberMetadataUpdate(memberDto, metadata) {
        const member = this._getMember(memberDto.id);
        member._metadataUpdated(metadata);
        const person = this._getPerson(memberDto.id);
        if (person) {
            person._metadataUpdated(metadata);
        }
        this.onMemberMetadataUpdated.emit({ member, metadata });
    }
    _handleOnStreamPublish(publicationDto) {
        const publication = this._addPublication(publicationDto);
        this.onStreamPublished.emit({ publication });
    }
    _handleOnStreamUnpublish(publicationDto) {
        const publication = this._getPublication(publicationDto.id);
        this._removePublication(publication.id);
        publication._unpublished();
        this.onStreamUnpublished.emit({ publication });
    }
    _handleOnStreamMetadataUpdate(publicationDto, metadata) {
        const publication = this._getPublication(publicationDto.id);
        publication._updateMetadata(metadata);
        this.onPublicationMetadataUpdated.emit({ publication, metadata });
    }
    _handleOnStreamSubscribe(subscriptionDto) {
        const subscription = this._addSubscription(subscriptionDto);
        const publication = this._getPublication(subscription.publication.id);
        publication._subscribed();
        this.onStreamSubscribed.emit({ subscription });
    }
    _handleOnStreamUnsubscribe(subscriptionDto) {
        const subscription = this._getSubscription(subscriptionDto.id);
        this._removeSubscription(subscription.id);
        subscription._canceled();
        const publication = this._getPublication(subscription.publication.id);
        publication._unsubscribed();
        this.onStreamUnsubscribed.emit({ subscription });
    }
    join(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.name != undefined) {
                const exist = this.members.find((m) => m.name === options.name);
                if (exist) {
                    throw new common_2.SkyWayError({
                        type: 'forbidden',
                        message: 'already exist same name member',
                        payload: options,
                    });
                }
            }
            if (options.keepaliveIntervalSec === undefined) {
                options.keepaliveIntervalSec = 25;
            }
            log.debug('join channel', { channelId: this.id, options });
            const init = Object.assign(Object.assign({}, options), { type: 'person', subtype: 'person' });
            if (options.keepaliveIntervalSec !== null) {
                init['ttlSec'] = Date.now() / 1000 + options.keepaliveIntervalSec;
            }
            const member = yield this._channelImpl.joinChannel(init);
            // todo fix?
            member.name = init.name;
            const person = yield this._createLocalPerson(member, {
                keepaliveIntervalSec: options.keepaliveIntervalSec,
            });
            const adapter = new __1.LocalPersonAdapter(person);
            return adapter;
        });
    }
    // よりよい名前が見つかったらリネームする
    memberMoveFromOtherChannel(adapter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(adapter instanceof __1.LocalPersonAdapter)) {
                throw new common_2.SkyWayError({
                    type: 'invalidType',
                    message: 'invalid person instance',
                });
            }
            const leaveChannel = adapter.channel;
            if (this.id === leaveChannel.id) {
                throw new common_2.SkyWayError({
                    type: 'invalidParameter',
                    message: 'same channel',
                });
            }
            yield leaveChannel.leave(adapter);
            const init = {
                name: adapter.name,
                type: adapter.type,
                subtype: adapter.subtype,
                metadata: adapter.metadata,
            };
            if (adapter.keepaliveIntervalSec != undefined) {
                init['ttlSec'] = Date.now() / 1000 + adapter.keepaliveIntervalSec;
            }
            const member = yield this._channelImpl.joinChannel(init);
            const person = yield this._createLocalPerson(member, {
                keepaliveIntervalSec: adapter.keepaliveIntervalSec,
            });
            adapter.apply(person);
        });
    }
    _createLocalPerson(member, { keepaliveIntervalSec }) {
        return __awaiter(this, void 0, void 0, function* () {
            const person = yield (0, __1.createLocalPerson)(this._context, this, member, {
                keepaliveIntervalSec,
            });
            this._addPerson(person);
            return person;
        });
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        log.debug('disposed', { id: this.id });
        this._onDisposed.emit();
        this._events.dispose();
        this._channelImpl.dispose();
    }
}
exports.SkyWayChannelImpl = SkyWayChannelImpl;
class SkyWayChannel {
    /**
     * @description {japanese} Channelの作成
     */
    static Create(context, init = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelImpl = yield context._api.createChannel(init);
            const channel = new SkyWayChannelImpl(context, channelImpl);
            return channel;
        });
    }
    /**
     * @description {japanese} 既存のChannelの取得
     */
    static Find(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelImpl = yield context._api.findChannel(query);
            const channel = new SkyWayChannelImpl(context, channelImpl);
            return channel;
        });
    }
    /**
     * @description {japanese} Channelの取得を試み、存在しなければ作成する
     */
    static FindOrCreate(context, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const channelImpl = yield context._api.findOrCreateChannel(query);
            const channel = new SkyWayChannelImpl(context, channelImpl);
            return channel;
        });
    }
    /**@private */
    constructor() { }
}
exports.SkyWayChannel = SkyWayChannel;
//# sourceMappingURL=index.js.map