"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcResponseError = exports.ReconnectHappenedError = exports.RPC = void 0;
const common_1 = require("@skyway-sdk/common");
const buffer_1 = require("buffer");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const uuid_1 = require("uuid");
const const_1 = require("./const");
const log = new common_1.Logger('packages/rtc-rpc-api-client/src/rpc.ts');
class RPC {
    constructor() {
        this.closed = false;
        this.connected = false;
        this.reconnecting = false;
        this._reconnectCount = 0;
        this._reconnectLimit = 3;
        this._pendingRequests = [];
        /**bytes */
        this.received = 0;
        this._events = new common_1.Events();
        this._onMessage = this._events.make();
        this.onNotify = this._events.make();
        this.onFatalError = this._events.make();
        this.onReconnect = this._events.make();
        this._send = (request) => new Promise((r, f) => __awaiter(this, void 0, void 0, function* () {
            // 非同期化
            yield new Promise((r) => setTimeout(r, 0));
            if (this._ws.readyState !== this._ws.OPEN) {
                f(new common_1.SkyWayError({
                    type: 'forbidden',
                    message: 'wrong state',
                    payload: {
                        request,
                        wsReadyState: wsStates[this._ws.readyState],
                    },
                }));
                return;
            }
            this._ws.send(JSON.stringify(request), (error) => {
                if (error) {
                    throw f(new common_1.SkyWayError({
                        type: 'internalError',
                        message: 'failed to send rpc message',
                        payload: error,
                    }));
                }
            });
            r();
        }));
    }
    connect({ domain, token, secure, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const subProtocol = token;
            this._ws = new isomorphic_ws_1.default(`${secure ? 'wss' : 'ws'}://${domain}/ws`, subProtocol);
            this._ws.onmessage = (ev) => {
                this.received += buffer_1.Buffer.byteLength(ev.data);
                this._onMessage.emit(JSON.parse(ev.data));
            };
            this._ws.onclose = (ev) => __awaiter(this, void 0, void 0, function* () {
                log.warn('ws connection closed', ev);
                if (this.connected && !this.closed) {
                    if (this._reconnectCount > this._reconnectLimit) {
                        this.onFatalError.emit(new common_1.SkyWayError({
                            type: 'backendError',
                            message: '_reconnectLimit exceeded',
                        }));
                        this.close();
                        return;
                    }
                    try {
                        yield this.reconnect({ domain, token, secure }).catch((e) => {
                            this.onFatalError.emit(e);
                            this.close();
                            throw e;
                        });
                        log.warn('resolve pendingRequests', [...this._pendingRequests]);
                        this._pendingRequests.forEach((req) => __awaiter(this, void 0, void 0, function* () {
                            yield this._send(req);
                        }));
                        this._pendingRequests = [];
                    }
                    catch (error) {
                        log.error(error);
                    }
                }
            });
            this._onMessage.add((msg) => {
                this._reconnectCount = 0;
                if (isNotifyMessage(msg)) {
                    this.onNotify.emit(msg);
                }
            });
            const error = yield new Promise((r, f) => {
                const timeout = setTimeout(() => {
                    f(new common_1.SkyWayError({ type: 'internalError', message: 'timeout' }));
                }, 10000);
                this._ws.onerror = (e) => {
                    log.error('ws error before established', e);
                    f(e);
                };
                this._ws.onopen = () => {
                    clearTimeout(timeout);
                    r();
                };
            }).catch((e) => e);
            if (error) {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: 'failed to connect rtc-api',
                    payload: error,
                });
            }
            this.connected = true;
        });
    }
    reconnect({ domain, token, secure, }) {
        return __awaiter(this, void 0, void 0, function* () {
            this._reconnectCount++;
            this.reconnecting = true;
            log.warn('[start] reconnect rtc api', {
                reconnectCount: this._reconnectCount,
            });
            yield this.connect({ domain, token, secure }).catch((err) => {
                log.warn(`[failed] reconnect rtc api`, {
                    reconnectCount: this._reconnectCount,
                });
                throw err;
            });
            this.reconnecting = false;
            log.warn('[end] reconnect rtc api', {
                reconnectCount: this._reconnectCount,
            });
            this.onReconnect.emit();
        });
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        log.debug('closed');
        this._ws.close();
        this._events.dispose();
    }
    /**
     * @throws {@link RpcResponseError}
     * @throws {@link ReconnectHappenedError}
     */
    request(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.closed) {
                throw new common_1.SkyWayError({ type: 'forbidden', message: 'rpc closed' });
            }
            let done = false;
            try {
                const request = buildRequest(method, params);
                const handleMessage = () => __awaiter(this, void 0, void 0, function* () {
                    return (yield this._onMessage
                        .watch((msg) => msg.id === request.id, const_1.rpcTimeout)
                        .catch(() => {
                        if (done) {
                            return;
                        }
                        throw new common_1.SkyWayError({
                            type: 'timeout',
                            message: 'rpc request timeout',
                            payload: {
                                method,
                                params,
                                wsReadyState: wsStates[this._ws.readyState],
                            },
                        });
                    }));
                });
                if (!this.reconnecting) {
                    this._send(request).catch((e) => {
                        throw e;
                    });
                    const message = yield Promise.race([
                        this.onFatalError.asPromise(const_1.rpcTimeout + 100).then((e) => {
                            if (!done) {
                                log.error('onFatalError', { method, params });
                            }
                            throw e;
                        }),
                        this.onReconnect.asPromise(const_1.rpcTimeout + 100).then(() => {
                            if (!done) {
                                log.error('reconnectHappened', { method, params });
                            }
                            throw new ReconnectHappenedError();
                        }),
                        handleMessage(),
                    ]);
                    if (message.error) {
                        log.error('[failed] request ', { message, method, params });
                        throw new RpcResponseError(message.error);
                    }
                    done = true;
                    return message.result;
                }
                else {
                    log.warn('[start] reconnecting. pending request', { request });
                    this._pendingRequests.push(request);
                    const message = yield Promise.race([
                        this.onFatalError.asPromise(const_1.rpcTimeout + 100).then((e) => {
                            if (!done) {
                                log.warn('[failed] reconnecting. pending request', { e });
                            }
                            throw e;
                        }),
                        handleMessage(),
                    ]);
                    if (message.error) {
                        log.warn('[failed] reconnecting. pending request', {
                            message,
                            request,
                        });
                        throw new RpcResponseError(message.error);
                    }
                    log.warn('[end] reconnecting. pending request', { request });
                    done = true;
                    return message.result;
                }
            }
            catch (error) {
                done = true;
                throw error;
            }
        });
    }
    notify(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = buildRequest(method, params, true);
            yield this._send(request);
        });
    }
    batch(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = requests.map(({ method, params }) => buildRequest(method, params));
            this._send(messages).catch((e) => {
                throw e;
            });
            const responses = yield Promise.all(messages.map(({ id }) => __awaiter(this, void 0, void 0, function* () {
                const message = (yield this._onMessage.watch((msg) => msg.id === id, const_1.rpcTimeout));
                return message;
            })));
            return responses;
        });
    }
}
exports.RPC = RPC;
const buildRequest = (method, params, notify) => {
    if (notify) {
        return { jsonrpc: '2.0', method, params };
    }
    const id = (0, uuid_1.v4)();
    return { jsonrpc: '2.0', method, params, id };
};
const isNotifyMessage = (msg) => {
    const notify = msg;
    if (notify.method && notify.id == undefined) {
        return true;
    }
    return false;
};
class ReconnectHappenedError extends common_1.SkyWayError {
    constructor() {
        super({ type: 'backendError', message: 'reconnectHappened' });
    }
}
exports.ReconnectHappenedError = ReconnectHappenedError;
class RpcResponseError extends common_1.SkyWayError {
    constructor(payload) {
        super({ type: 'backendError', message: 'request failed', payload });
    }
}
exports.RpcResponseError = RpcResponseError;
const wsStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
//# sourceMappingURL=rpc.js.map