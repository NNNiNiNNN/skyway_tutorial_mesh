"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RtcRpcApiClient = void 0;
const common_1 = require("@skyway-sdk/common");
const const_1 = require("./const");
const rpc_1 = require("./rpc");
const log = new common_1.Logger('packages/rtc-rpc-api-client/src/client.ts');
class RtcRpcApiClient {
    constructor(args) {
        var _a, _b;
        this.args = args;
        this.closed = false;
        this._domain = (_a = this.args.domain) !== null && _a !== void 0 ? _a : const_1.defaultDomain;
        this._secure = (_b = this.args.secure) !== null && _b !== void 0 ? _b : true;
        this._token = this.args.token;
        /**@private */
        this._rpc = new rpc_1.RPC();
        this._subscribingChannelEvents = new Set();
        this._subscribingChannelVersions = {};
        this._httpClient = new common_1.HttpClient(`http${this.args.secure ? 's' : ''}://${this.args.domain}`);
        this._events = new common_1.Events();
        this.onEvent = this._events.make();
        this.onFatalError = this._events.make();
        this.onClose = this._events.make();
        if (args.logLevel) {
            common_1.Logger.level = args.logLevel;
        }
        log.debug('RtcRpcApiClient spawned', args);
        this._rpc.onNotify.add((notify) => {
            if (notify.method === 'channelEventNotification') {
                const event = notify.params;
                this._subscribingChannelVersions[event.data.channel.id] =
                    event.data.channel.version;
                this.onEvent.emit({ channelId: event.data.channel.id, event });
            }
        });
        this._rpc.onFatalError.once((e) => {
            log.error('fatal error', e);
            this.onFatalError.emit(e);
            this.close();
        });
        this._rpc.onReconnect.add(() => {
            log.warn('re subscribe channel events', {
                _subscribingChannelEvents: [...this._subscribingChannelEvents],
            });
            [...this._subscribingChannelEvents].forEach((s) => __awaiter(this, void 0, void 0, function* () {
                const [appId, channelId] = s.split(':');
                const offset = this._subscribingChannelVersions[channelId];
                yield this.subscribeChannelEvents({
                    appId,
                    channelId,
                    offset,
                });
            }));
        });
    }
    updateToken(token) {
        log.debug('token update', { token });
        this._token = token;
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        log.debug('closed');
        this._rpc.close();
        this.onClose.emit();
        this._events.dispose();
    }
    health() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._httpClient.get('/health');
            return response;
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('connect to rtc api rpc', this._domain);
            yield this._rpc
                .connect({
                domain: this._domain,
                token: this._token,
                secure: this._secure,
            })
                .catch((e) => {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: 'failed to connect rpc api',
                    payload: {
                        reason: 'There may be a problem with the token or failure on the server side',
                        error: e,
                    },
                });
            });
        });
    }
    _channelSubscribed(appId, channelId) {
        this._subscribingChannelEvents.add(appId + ':' + channelId);
        log.debug('_channelSubscribed', {
            appId,
            channelId,
            _subscribingChannelEvents: [...this._subscribingChannelEvents],
        });
    }
    _isSubscribingChannel(appId, channelId) {
        return this._subscribingChannelEvents.has(appId + ':' + channelId);
    }
    createChannel({ name, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { channel } = yield this._rpc.request('createChannel', {
                name,
                metadata,
                appId,
                authToken: this._token,
            });
            this._channelSubscribed(appId, channel.id);
            return channel;
        });
    }
    findOrCreateChannel({ name, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { channel } = yield this._rpc.request('findOrCreateChannel', {
                name,
                metadata,
                appId,
                authToken: this._token,
            });
            this._channelSubscribed(appId, channel.id);
            return channel;
        });
    }
    getChannel({ appId, id }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('getChannel', {
                id,
                appId,
                authToken: this._token,
            });
            // getChannelは暗黙的にEventがsubscribeされない
            if (!this._isSubscribingChannel(appId, id)) {
                this._channelSubscribed(appId, id);
                yield this.subscribeChannelEvents({
                    appId,
                    channelId: id,
                    offset: res.channel.version,
                });
            }
            else {
                log.warn('debug _isSubscribingChannel', { appId, id });
            }
            return res.channel;
        });
    }
    getChannelByName({ name, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('getChannelByName', {
                name,
                appId,
                authToken: this._token,
            });
            return res.channel;
        });
    }
    deleteChannel({ id, appId }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('deleteChannel', {
                id,
                appId,
                authToken: this._token,
            });
        });
    }
    updateChannelMetadata({ id, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updateChannelMetadata', {
                id,
                metadata,
                appId,
                authToken: this._token,
            });
        });
    }
    addMember({ channelId, name, metadata, subscribeChannelEvents, appId, ttlSec, subtype, type, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('addMember', {
                channelId,
                name,
                metadata,
                subscribeChannelEvents,
                appId,
                ttlSec: ttlSec && parseInt(ttlSec.toString()),
                authToken: this._token,
                subtype,
                type,
            });
            return res;
        });
    }
    updateMemberTtl(args, retry = 2) {
        return __awaiter(this, void 0, void 0, function* () {
            const { appId, channelId, memberId, ttlSec } = args;
            try {
                yield this._rpc.request('updateMemberTtl', {
                    appId,
                    channelId,
                    memberId,
                    ttlSec: ttlSec && parseInt(ttlSec.toString()),
                    authToken: this._token,
                });
            }
            catch (e) {
                const error = new common_1.SkyWayError({
                    type: 'internalError',
                    message: 'updateMemberTtl failed',
                    payload: e,
                });
                if (retry > 0) {
                    log.warn('retry updateMemberTtl', { error, retry });
                    yield this.updateMemberTtl(args, retry - 1);
                }
                else {
                    throw error;
                }
            }
        });
    }
    updateMemberMetadata({ channelId, memberId, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updateMemberMetadata', {
                channelId,
                memberId,
                metadata,
                appId,
                authToken: this._token,
            });
        });
    }
    leaveChannel({ channelId, id, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('removeMember', {
                channelId,
                id,
                appId,
                authToken: this._token,
            });
        });
    }
    publishStream({ appId, channelId, publisherId, contentType, metadata, origin, codecCapabilities, encodings, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('publishStream', {
                channelId,
                publisherId,
                // todo fix
                contentType: contentType[0].toUpperCase() + contentType.slice(1),
                metadata,
                origin,
                codecCapabilities,
                encodings,
                appId,
                authToken: this._token,
            });
            return { publicationId: res.id };
        });
    }
    updatePublicationMetadata({ channelId, publicationId, appId, metadata, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updatePublicationMetadata', {
                channelId,
                publicationId,
                metadata,
                appId,
                authToken: this._token,
            });
        });
    }
    unpublishStream({ channelId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('unpublishStream', {
                channelId,
                publicationId,
                appId,
                authToken: this._token,
            });
        });
    }
    subscribeStream({ channelId, subscriberId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('subscribeStream', {
                channelId,
                subscriberId,
                publicationId,
                appId,
                authToken: this._token,
            });
            return { subscriptionId: res.id };
        });
    }
    unsubscribeStream({ channelId, subscriptionId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('unsubscribeStream', {
                channelId,
                subscriptionId,
                appId,
                authToken: this._token,
            });
        });
    }
    /** @description
     * - 指定した Channel の Event を Subscribe していなければ Event が生じるたびに Notification が送られるようになります。
     * - Subscribeした時点で、指定された offset (default to 0) の version から、最新の version までのイベントが送られます。
     */
    subscribeChannelEvents({ appId, channelId, offset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                log.debug('[start] subscribeChannelEvents', { offset });
                yield this._rpc.request('subscribeChannelEvents', {
                    appId,
                    authToken: this._token,
                    channelId,
                    offset,
                });
                log.debug('[end] subscribeChannelEvents', { offset });
            }
            catch (error) {
                if (error instanceof rpc_1.ReconnectHappenedError) {
                    log.warn('reconnect happened while subscribeChannelEvents. retry', {
                        offset,
                        error,
                    });
                    yield this.subscribeChannelEvents({ appId, channelId, offset });
                }
                else {
                    log.warn('[failed] subscribeChannelEvents', { offset, error });
                    throw error;
                }
            }
        });
    }
}
exports.RtcRpcApiClient = RtcRpcApiClient;
//# sourceMappingURL=client.js.map