"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const event_1 = require("./utils/event");
const version_1 = require("./version");
const getReconnectWaitTime = (reconnectCount) => {
    return (Math.pow(2, reconnectCount) + Math.random()) * 1000;
};
class Socket {
    constructor({ channelId, channelName, memberId, memberName, sessionEndpoint, token, connectivityCheckIntervalSec, logger, }) {
        this._isOpen = false;
        this._isDestroyed = false;
        this._reconnectCount = 0;
        this.onOpened = new event_1.Event();
        this.onEventReceived = new event_1.Event();
        this.onConnectionFailed = new event_1.Event();
        this._sessionEndpoint = sessionEndpoint;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        this._token = token;
        this._connectivityCheckIntervalSec = connectivityCheckIntervalSec;
        this._logger = logger;
        this._connect();
    }
    _reconnect() {
        this._ws = undefined;
        this._isOpen = false;
        if (this._reconnectCount >= 3) {
            this.onConnectionFailed.emit();
            this.destroy();
            this._logger.error('Failed to reconnect for three times', new Error());
        }
        else {
            const waitTime = getReconnectWaitTime(this._reconnectCount);
            setTimeout(() => {
                this._connect();
                this._reconnectCount++;
                this._logger.debug(`Try to reconnect: count = ${this._reconnectCount}`);
            }, waitTime);
        }
    }
    _connect() {
        let ws;
        try {
            // We use the SubProtocol header to send the token.
            // This is because the browser's WebSocket class does not allow the header to be changed freely.
            const subProtocol = `SkyWayJWT!${this._token}`;
            const wsProperties = {
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                connectivityCheckIntervalSec: this._connectivityCheckIntervalSec,
                platform: 'javascript',
                version: version_1.PACKAGE_VERSION,
            };
            const queryString = Object.entries(wsProperties)
                .filter(([_, v]) => v !== undefined)
                .map((pair) => pair.join('='))
                .join('&');
            const wsURL = `${this._sessionEndpoint}?${queryString}`;
            // Send Node.js version as User-Agent when running on Node.js
            const isNodeJS = typeof process === 'object' && process.versions !== null && process.versions.node !== null;
            if (isNodeJS) {
                ws = new isomorphic_ws_1.default(wsURL, subProtocol, {
                    headers: {
                        'User-Agent': `skyway-message-js-client/${process.version}`,
                    },
                });
            }
            else {
                ws = new isomorphic_ws_1.default(wsURL, subProtocol);
            }
            this._logger.debug(`Connecting to message-server: ${this._sessionEndpoint}`);
            ws.onerror = (event) => {
                this._logger.error('WebSocket error occurred', event.error);
                this._reconnect();
            };
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error('Failed to create WebSocket instance', error);
            this._reconnect();
            return;
        }
        ws.onopen = () => {
            this._logger.debug('Connected to message-server');
        };
        ws.onclose = (event) => {
            this._logger.debug('Close event fired: ' + JSON.stringify(event));
            // 1000, 4000~4099: normal case (should not reconnect)
            // 4100~4199: non-normal case (should not reconnect)
            // 4200~4299: non-normal case (should reconnect)
            // others: unexpected case (should reconnect)
            if (event.code !== 1000 && !(4000 <= event.code && event.code <= 4199)) {
                this._reconnect();
                return;
            }
            this._logger.debug('Closed the connection to message-server');
            this.onConnectionFailed.emit();
            this.destroy();
        };
        ws.onmessage = (event) => {
            this._messageHandler(event.data);
        };
        this._ws = ws;
    }
    destroy() {
        this._isDestroyed = true;
        this.onOpened.removeAllListeners();
        this.onEventReceived.removeAllListeners();
        this.onConnectionFailed.removeAllListeners();
        if (this._ws !== undefined) {
            this._ws.close(1000);
        }
    }
    send(order) {
        return new Promise((resolve, reject) => {
            const retrySend = () => {
                this.onOpened.addOneTimeListener(() => {
                    this.send(order)
                        .then(() => {
                        resolve();
                    })
                        .catch((err) => {
                        reject(err);
                    });
                });
                this.onConnectionFailed.addOneTimeListener(() => {
                    reject(new Error('Connection failed'));
                });
            };
            if (this._isDestroyed) {
                reject(new Error('The socket is already destroyed'));
                return;
            }
            if (this._ws === undefined || !this._isOpen) {
                // Call send method again after connected
                this._logger.debug('Retry send the order when connected because WebSocket is undefined or isOpen = false');
                retrySend();
                return;
            }
            this._logger.debug(`Send the event: ${order.data}`);
            this._ws.send(order.data, (err) => {
                if (err) {
                    // If state is invalid, call send method again after reconnected
                    if (this._ws === undefined || !this._isOpen || this._ws.readyState !== isomorphic_ws_1.default.OPEN) {
                        this._logger.debug('Retry send the order when connected because WebSocket.send failed');
                        retrySend();
                        return;
                    }
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    _messageHandler(data) {
        if (typeof data !== 'string') {
            this._logger.error('Received invalid message: not string', new Error());
            return;
        }
        let parsedData;
        try {
            parsedData = JSON.parse(data);
        }
        catch (err) {
            const error = err instanceof Error ? err : new Error();
            this._logger.error('Received invalid message: parse error', error);
            return;
        }
        if (!isEventData(parsedData)) {
            this._logger.error(`Received invalid message: ${parsedData}`, new Error());
            return;
        }
        if (parsedData.event === 'open') {
            this._logger.debug('Received a open event');
            this._isOpen = true;
            if (this._reconnectCount !== 0) {
                this._reconnectCount = 0;
                this._logger.debug('Succeeded to reconnect');
            }
            this.onOpened.emit();
        }
        else {
            this._logger.debug(`Received the event: ${parsedData.event}, payload: ${parsedData.payload}`);
            this.onEventReceived.emit(parsedData);
        }
    }
}
exports.Socket = Socket;
function isEventData(data) {
    if (!data || typeof data !== 'object')
        return false;
    if (typeof data.event !== 'string')
        return false;
    if (data.payload && typeof data.payload !== 'object')
        return false;
    return true;
}
//# sourceMappingURL=socket.js.map