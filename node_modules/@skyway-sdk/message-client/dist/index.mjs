var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __pow = Math.pow;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// bundler/shims/process.js
var process;
var init_process = __esm({
  "bundler/shims/process.js"() {
    process = void 0;
  }
});

// ../../node_modules/whatwg-fetch/dist/fetch.umd.js
var require_fetch_umd = __commonJS({
  "../../node_modules/whatwg-fetch/dist/fetch.umd.js"(exports, module) {
    init_process();
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.WHATWGFetch = {});
    })(exports, function(exports2) {
      "use strict";
      var global2 = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
      var support = {
        searchParams: "URLSearchParams" in global2,
        iterable: "Symbol" in global2 && "iterator" in Symbol,
        blob: "FileReader" in global2 && "Blob" in global2 && function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        }(),
        formData: "FormData" in global2,
        arrayBuffer: "ArrayBuffer" in global2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name) {
        if (typeof name !== "string") {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
          throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items) {
        var iterator = {
          next: function() {
            var value = items.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (Array.isArray(headers)) {
          headers.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ", " + value : value;
      };
      Headers.prototype["delete"] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        for (var name in this.map) {
          if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
          }
        }
      };
      Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push(name);
        });
        return iteratorFor(items);
      };
      Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
          items.push(value);
        });
        return iteratorFor(items);
      };
      Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
          items.push([name, value]);
        });
        return iteratorFor(items);
      };
      if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i = 0; i < view.length; i++) {
          chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this.bodyUsed = this.bodyUsed;
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              }
              if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request(input, options) {
        if (!(this instanceof Request)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
        if (this.method === "GET" || this.method === "HEAD") {
          if (options.cache === "no-store" || options.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
              this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
            } else {
              var reQueryString = /\?/;
              this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
            }
          }
        }
      }
      Request.prototype.clone = function() {
        return new Request(this, { body: this._bodyInit });
      };
      function decode(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers = new Headers();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split("\r").map(function(header) {
          return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
        }).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers.append(key, value);
          }
        });
        return headers;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!(this instanceof Response)) {
          throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
        this.headers = new Headers(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response(null, { status, headers: { location: url } });
      };
      exports2.DOMException = global2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name) {
          this.message = message;
          this.name = name;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init) {
        return new Promise(function(resolve, reject) {
          var request = new Request(input, init);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
              resolve(new Response(body, options));
            }, 0);
          };
          xhr.onerror = function() {
            setTimeout(function() {
              reject(new TypeError("Network request failed"));
            }, 0);
          };
          xhr.ontimeout = function() {
            setTimeout(function() {
              reject(new TypeError("Network request failed"));
            }, 0);
          };
          xhr.onabort = function() {
            setTimeout(function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            }, 0);
          };
          function fixUrl(url) {
            try {
              return url === "" && global2.location.href ? global2.location.href : url;
            } catch (e) {
              return url;
            }
          }
          xhr.open(request.method, fixUrl(request.url), true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr) {
            if (support.blob) {
              xhr.responseType = "blob";
            } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
              xhr.responseType = "arraybuffer";
            }
          }
          if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
            Object.getOwnPropertyNames(init.headers).forEach(function(name) {
              xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
            });
          } else {
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
          }
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!global2.fetch) {
        global2.fetch = fetch2;
        global2.Headers = Headers;
        global2.Request = Request;
        global2.Response = Response;
      }
      exports2.Headers = Headers;
      exports2.Request = Request;
      exports2.Response = Response;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  "../../node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
    init_process();
    require_fetch_umd();
    module.exports = self.fetch.bind(self);
  }
});

// ../../node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "../../node_modules/isomorphic-ws/browser.js"(exports, module) {
    init_process();
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// src/index.ts
init_process();

// src/messageClient.ts
init_process();
var import_isomorphic_fetch = __toESM(require_fetch_npm_browserify());

// node_modules/uuid/dist/esm-browser/index.js
init_process();

// node_modules/uuid/dist/esm-browser/rng.js
init_process();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
init_process();

// node_modules/uuid/dist/esm-browser/validate.js
init_process();

// node_modules/uuid/dist/esm-browser/regex.js
init_process();
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
init_process();
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// src/order.ts
init_process();
var MAX_PAYLOAD_LENGTH = 20480;
var Order = class {
  constructor(name, payload = {}) {
    this.name = name;
    this.payload = payload;
    this.id = v4_default();
    this.data = this.payload === {} ? JSON.stringify({ order: this.name, orderId: this.id }) : JSON.stringify({ order: this.name, orderId: this.id, payload: this.payload });
    if (this.data.length > MAX_PAYLOAD_LENGTH) {
      throw new Error("payload size exceeds the upper limit");
    }
  }
};

// src/payloadTypes.ts
init_process();
var MessageKind = ["indicate", "request", "response"];
function isMessagePayload(payload) {
  if (!payload || typeof payload !== "object")
    return false;
  if (!isMember(payload.src))
    return false;
  if (typeof payload.kind !== "string" || !MessageKind.includes(payload.kind))
    return false;
  if (payload.kind === "indicate" && typeof payload.isBroadcast !== "boolean")
    return false;
  if ((payload.kind === "request" || payload.kind === "response") && typeof payload.requestOrderId !== "string") {
    return false;
  }
  if (!payload.data || typeof payload.data !== "object")
    return false;
  return true;
}
function isOrderAcceptedPayload(payload) {
  if (!payload || typeof payload !== "object")
    return false;
  if (typeof payload.orderId !== "string")
    return false;
  return true;
}
function isOrderRejectedPayload(payload) {
  if (!payload || typeof payload !== "object")
    return false;
  if (typeof payload.orderId !== "string")
    return false;
  if (typeof payload.reason !== "string")
    return false;
  return true;
}
function isMember(arg) {
  if (arg === void 0 || Array.isArray(arg))
    return false;
  if (typeof arg !== "object")
    return false;
  if (typeof arg.id !== "string")
    return false;
  if (typeof arg.name !== "undefined" && typeof arg.name !== "string")
    return false;
  return true;
}

// src/socket.ts
init_process();
var import_isomorphic_ws = __toESM(require_browser());

// src/utils/event.ts
init_process();
var Event = class {
  constructor() {
    this._listeners = /* @__PURE__ */ new Map();
    this._listenerIndex = 0;
    this.emit = (arg) => {
      this._listeners.forEach((listener) => listener(arg));
    };
    this.removeAllListeners = () => {
      this._listeners.clear();
    };
    this.addListener = (listener) => {
      const id = this._listenerIndex;
      this._listeners.set(id, listener);
      this._listenerIndex++;
      const removeListener = () => {
        this._listeners.delete(id);
      };
      return { removeListener };
    };
    this.addOneTimeListener = (listener) => {
      const off = this.addListener((arg) => {
        off.removeListener();
        listener(arg);
      });
      return off;
    };
    this.asPromise = (timeLimit) => new Promise((resolve, reject) => {
      let removeListener = () => {
      };
      const timeout = timeLimit && setTimeout(() => {
        reject("Event asPromise timeout");
        removeListener();
      }, timeLimit);
      const off = this.addOneTimeListener((arg) => {
        if (timeout)
          clearTimeout(timeout);
        resolve(arg);
      });
      removeListener = off.removeListener;
    });
  }
};

// src/version.ts
init_process();
var PACKAGE_VERSION = "0.2.0-beta.0";

// src/socket.ts
var getReconnectWaitTime = (reconnectCount) => {
  return (__pow(2, reconnectCount) + Math.random()) * 1e3;
};
var Socket = class {
  constructor({
    channelId,
    channelName,
    memberId,
    memberName,
    sessionEndpoint,
    token,
    connectivityCheckIntervalSec,
    logger
  }) {
    this._isOpen = false;
    this._isDestroyed = false;
    this._reconnectCount = 0;
    this.onOpened = new Event();
    this.onEventReceived = new Event();
    this.onConnectionFailed = new Event();
    this._sessionEndpoint = sessionEndpoint;
    this._channelId = channelId;
    this._channelName = channelName;
    this._memberId = memberId;
    this._memberName = memberName;
    this._token = token;
    this._connectivityCheckIntervalSec = connectivityCheckIntervalSec;
    this._logger = logger;
    this._connect();
  }
  _reconnect() {
    this._ws = void 0;
    this._isOpen = false;
    if (this._reconnectCount >= 3) {
      this.onConnectionFailed.emit();
      this.destroy();
      this._logger.error("Failed to reconnect for three times", new Error());
    } else {
      const waitTime = getReconnectWaitTime(this._reconnectCount);
      setTimeout(() => {
        this._connect();
        this._reconnectCount++;
        this._logger.debug(`Try to reconnect: count = ${this._reconnectCount}`);
      }, waitTime);
    }
  }
  _connect() {
    let ws;
    try {
      const subProtocol = `SkyWayJWT!${this._token}`;
      const wsProperties = {
        channelId: this._channelId,
        channelName: this._channelName,
        memberId: this._memberId,
        memberName: this._memberName,
        connectivityCheckIntervalSec: this._connectivityCheckIntervalSec,
        platform: "javascript",
        version: PACKAGE_VERSION
      };
      const queryString = Object.entries(wsProperties).filter(([_, v]) => v !== void 0).map((pair) => pair.join("=")).join("&");
      const wsURL = `${this._sessionEndpoint}?${queryString}`;
      const isNodeJS = typeof process === "object" && process.versions !== null && process.versions.node !== null;
      if (isNodeJS) {
        ws = new import_isomorphic_ws.default(wsURL, subProtocol, {
          headers: {
            "User-Agent": `skyway-message-js-client/${process.version}`
          }
        });
      } else {
        ws = new import_isomorphic_ws.default(wsURL, subProtocol);
      }
      this._logger.debug(`Connecting to message-server: ${this._sessionEndpoint}`);
      ws.onerror = (event) => {
        this._logger.error("WebSocket error occurred", event.error);
        this._reconnect();
      };
    } catch (err) {
      const error = err instanceof Error ? err : new Error();
      this._logger.error("Failed to create WebSocket instance", error);
      this._reconnect();
      return;
    }
    ws.onopen = () => {
      this._logger.debug("Connected to message-server");
    };
    ws.onclose = (event) => {
      this._logger.debug("Close event fired: " + JSON.stringify(event));
      if (event.code !== 1e3 && !(4e3 <= event.code && event.code <= 4199)) {
        this._reconnect();
        return;
      }
      this._logger.debug("Closed the connection to message-server");
      this.onConnectionFailed.emit();
      this.destroy();
    };
    ws.onmessage = (event) => {
      this._messageHandler(event.data);
    };
    this._ws = ws;
  }
  destroy() {
    this._isDestroyed = true;
    this.onOpened.removeAllListeners();
    this.onEventReceived.removeAllListeners();
    this.onConnectionFailed.removeAllListeners();
    if (this._ws !== void 0) {
      this._ws.close(1e3);
    }
  }
  send(order) {
    return new Promise((resolve, reject) => {
      const retrySend = () => {
        this.onOpened.addOneTimeListener(() => {
          this.send(order).then(() => {
            resolve();
          }).catch((err) => {
            reject(err);
          });
        });
        this.onConnectionFailed.addOneTimeListener(() => {
          reject(new Error("Connection failed"));
        });
      };
      if (this._isDestroyed) {
        reject(new Error("The socket is already destroyed"));
        return;
      }
      if (this._ws === void 0 || !this._isOpen) {
        this._logger.debug("Retry send the order when connected because WebSocket is undefined or isOpen = false");
        retrySend();
        return;
      }
      this._logger.debug(`Send the event: ${order.data}`);
      this._ws.send(order.data, (err) => {
        if (err) {
          if (this._ws === void 0 || !this._isOpen || this._ws.readyState !== import_isomorphic_ws.default.OPEN) {
            this._logger.debug("Retry send the order when connected because WebSocket.send failed");
            retrySend();
            return;
          }
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  _messageHandler(data) {
    if (typeof data !== "string") {
      this._logger.error("Received invalid message: not string", new Error());
      return;
    }
    let parsedData;
    try {
      parsedData = JSON.parse(data);
    } catch (err) {
      const error = err instanceof Error ? err : new Error();
      this._logger.error("Received invalid message: parse error", error);
      return;
    }
    if (!isEventData(parsedData)) {
      this._logger.error(`Received invalid message: ${parsedData}`, new Error());
      return;
    }
    if (parsedData.event === "open") {
      this._logger.debug("Received a open event");
      this._isOpen = true;
      if (this._reconnectCount !== 0) {
        this._reconnectCount = 0;
        this._logger.debug("Succeeded to reconnect");
      }
      this.onOpened.emit();
    } else {
      this._logger.debug(`Received the event: ${parsedData.event}, payload: ${parsedData.payload}`);
      this.onEventReceived.emit(parsedData);
    }
  }
};
function isEventData(data) {
  if (!data || typeof data !== "object")
    return false;
  if (typeof data.event !== "string")
    return false;
  if (data.payload && typeof data.payload !== "object")
    return false;
  return true;
}

// src/messageClient.ts
var MSAS_DOMAIN = "b-msas.beta.skyway.ntt.com";
var API_VERSION = "v1";
var MessageClient = class {
  constructor({ token, channelId, channelName, memberId, memberName }, options) {
    this.onConnectionFailed = new Event();
    this.onRequested = new Event();
    this.onIndicated = new Event();
    this._responseCallbacks = {};
    this._orderAcceptedCallbacks = {};
    this._orderRejectedCallbacks = {};
    this._token = token;
    this._channelId = channelId;
    this._channelName = channelName;
    this._memberId = memberId;
    this._memberName = memberName;
    const defaultOptions = {
      connectivityCheckIntervalSec: 30,
      msasDomain: MSAS_DOMAIN,
      secure: true,
      logger: {
        debug: (message) => {
          console.debug(message);
        },
        error: (error) => {
          console.error(error);
        }
      }
    };
    this._options = Object.assign({}, defaultOptions, options != null ? options : {});
    this._logger = this._options.logger;
    this._logger.debug(`Created instance with the options: ${this._options}`);
  }
  connect() {
    return __async(this, null, function* () {
      const RESTProtocol = this._options.secure ? "https" : "http";
      const queryString = `channelId=${this._channelId}`;
      let sessionDomain;
      try {
        const response = yield (0, import_isomorphic_fetch.default)(`${RESTProtocol}://${this._options.msasDomain}/${API_VERSION}/sessions?${queryString}`, {
          headers: {
            Authorization: `Bearer ${this._token}`
          }
        }).then((res) => res.json());
        sessionDomain = response.domain;
      } catch (error) {
        console.error(error);
      }
      if (!sessionDomain) {
        throw new Error("The response from SkyWay Server (MSAS) is empty");
      }
      const WSProtocol = this._options.secure ? "wss" : "ws";
      this._socket = new Socket({
        sessionEndpoint: `${WSProtocol}://${sessionDomain}/${API_VERSION}/ws`,
        channelId: this._channelId,
        channelName: this._channelName,
        memberId: this._memberId,
        memberName: this._memberName,
        token: this._token,
        connectivityCheckIntervalSec: this._options.connectivityCheckIntervalSec,
        logger: this._logger
      });
      this._socket.onEventReceived.addListener((data) => {
        this._eventReceivedHandler(data);
      });
      this._socket.onConnectionFailed.addListener(() => {
        this.onConnectionFailed.emit();
      });
      yield this._socket.onOpened.asPromise(15 * 1e3);
      this._startConnectivityCheck();
    });
  }
  disconnect() {
    var _a;
    this._stopConnectivityCheck();
    (_a = this._socket) == null ? void 0 : _a.destroy();
    this._socket = void 0;
  }
  _startConnectivityCheck() {
    if (this._connectivityCheckTimer) {
      this._logger.debug("connectivity check timer is already set");
      return;
    }
    this._connectivityCheckTimer = setInterval(() => {
      var _a;
      (_a = this._socket) == null ? void 0 : _a.send(new Order("connectivityCheck")).catch(() => {
      });
    }, this._options.connectivityCheckIntervalSec * 1e3);
    this._logger.debug("Started connectivity check timer");
  }
  _stopConnectivityCheck() {
    if (!this._connectivityCheckTimer) {
      this._logger.debug("connectivity check timer is not set");
      return;
    }
    clearInterval(this._connectivityCheckTimer);
    this._connectivityCheckTimer = void 0;
    this._logger.debug("Stopped connectivity check timer");
  }
  indicate(targets, data, timeoutSec = 10) {
    return new Promise((resolve, reject) => {
      if (!Array.isArray(targets)) {
        targets = [targets];
      }
      if (targets.length === 0) {
        reject(new Error("targets is empty"));
        return;
      }
      for (const target of targets) {
        validateTarget(target);
      }
      validateData(data);
      if (this._socket === void 0) {
        reject(new Error("websocket is not connected"));
        return;
      }
      const payload = {
        kind: "indicate",
        isBroadcast: false,
        dst: targets,
        data
      };
      const order = new Order("message", payload);
      const timer = setTimeout(() => {
        this._clearOrderCallbacks(order.id);
        reject(new Error("indicate timeout"));
      }, timeoutSec * 1e3);
      this._setOrderAcceptedCallback(order.id, () => {
        clearTimeout(timer);
        resolve();
      });
      this._setOrderRejectedCallback(order.id, (data2) => {
        clearTimeout(timer);
        reject(data2);
      });
      this._socket.send(order).catch((err) => {
        this._clearOrderCallbacks(order.id);
        clearTimeout(timer);
        reject(err);
      });
    });
  }
  indicateAll(data, timeoutSec = 10) {
    return new Promise((resolve, reject) => {
      validateData(data);
      if (this._socket === void 0) {
        reject(new Error("websocket is not connected"));
        return;
      }
      const payload = {
        kind: "indicate",
        isBroadcast: true,
        data
      };
      const order = new Order("message", payload);
      const timer = setTimeout(() => {
        this._clearOrderCallbacks(order.id);
        reject(new Error("indicateAll timeout"));
      }, timeoutSec * 1e3);
      this._setOrderAcceptedCallback(order.id, () => {
        clearTimeout(timer);
        resolve();
      });
      this._setOrderRejectedCallback(order.id, (data2) => {
        clearTimeout(timer);
        reject(data2);
      });
      this._socket.send(order).catch((err) => {
        this._clearOrderCallbacks(order.id);
        clearTimeout(timer);
        reject(err);
      });
    });
  }
  request(target, data, timeoutSec = 10) {
    validateTarget(target);
    validateData(data);
    return new Promise((resolve, reject) => {
      if (this._socket === void 0) {
        reject(new Error("websocket is not connected"));
        return;
      }
      const payload = {
        kind: "request",
        dst: target,
        data
      };
      const order = new Order("message", payload);
      const timer = setTimeout(() => {
        delete this._responseCallbacks[order.id];
        delete this._orderRejectedCallbacks[order.id];
        reject(new Error("request timeout"));
      }, timeoutSec * 1e3);
      this._setResponseCallback(order.id, (data2) => {
        clearTimeout(timer);
        resolve(data2);
      });
      this._setOrderRejectedCallback(order.id, (data2) => {
        clearTimeout(timer);
        reject(data2);
      });
      this._setOrderAcceptedCallback(order.id, () => {
      });
      this._socket.send(order).catch((err) => {
        delete this._responseCallbacks[order.id];
        delete this._orderRejectedCallbacks[order.id];
        clearTimeout(timer);
        reject(err);
      });
    });
  }
  _response(target, requestOrderId, data, timeoutSec) {
    return new Promise((resolve, reject) => {
      validateData(data);
      if (this._socket === void 0) {
        reject(new Error("websocket is not connected"));
        return;
      }
      const payload = {
        kind: "response",
        dst: target,
        requestOrderId,
        data
      };
      const order = new Order("message", payload);
      const timer = setTimeout(() => {
        this._clearOrderCallbacks(order.id);
        reject(new Error("response timeout"));
      }, timeoutSec * 1e3);
      this._setOrderAcceptedCallback(order.id, () => {
        clearTimeout(timer);
        resolve();
      });
      this._setOrderRejectedCallback(order.id, (data2) => {
        clearTimeout(timer);
        reject(data2);
      });
      this._socket.send(order).catch((err) => {
        this._clearOrderCallbacks(order.id);
        clearTimeout(timer);
        reject(err);
      });
    });
  }
  _eventReceivedHandler(data) {
    switch (data.event) {
      case "orderAccepted":
        this._orderAcceptedHandler(data.payload);
        break;
      case "orderRejected":
        this._orderRejectedHandler(data.payload);
        break;
      case "message":
        this._eventMessageHandler(data.payload);
        break;
    }
  }
  _orderAcceptedHandler(payload) {
    if (!isOrderAcceptedPayload(payload)) {
      throw new Error("Invalid payload");
    }
    const orderId = payload.orderId;
    if (!this._orderAcceptedCallbacks[orderId]) {
      throw new Error(`accepted event has unknown orderId: ${orderId}`);
    }
    const callback = this._orderAcceptedCallbacks[orderId];
    this._clearOrderCallbacks(orderId);
    callback();
  }
  _orderRejectedHandler(payload) {
    if (!isOrderRejectedPayload(payload)) {
      throw new Error("Invalid payload");
    }
    const orderId = payload.orderId;
    if (!this._orderRejectedCallbacks[orderId]) {
      throw new Error(`rejected event has unknown orderId: ${orderId}`);
    }
    const callback = this._orderRejectedCallbacks[orderId];
    this._clearOrderCallbacks(orderId);
    callback(payload);
  }
  _eventMessageHandler(payload) {
    if (!isMessagePayload(payload)) {
      throw new Error("Invalid payload");
    }
    switch (payload.kind) {
      case "indicate":
        this._eventMessageIndicateHandler(payload);
        break;
      case "request":
        this._eventMessageRequestHandler(payload);
        break;
      case "response":
        this._eventMessageResponseHandler(payload);
        break;
    }
  }
  _eventMessageIndicateHandler(payload) {
    this.onIndicated.emit({
      data: payload.data,
      src: payload.src
    });
  }
  _eventMessageRequestHandler(payload) {
    if (!payload.requestOrderId) {
      throw new Error("Invalid payload");
    }
    const src = payload.src;
    const requestOrderId = payload.requestOrderId;
    const reply = (data, timeout = 10) => __async(this, null, function* () {
      yield this._response(src, requestOrderId, data, timeout);
    });
    this.onRequested.emit({
      data: payload.data,
      reply,
      requestOrderId: payload.requestOrderId,
      src: payload.src
    });
  }
  _eventMessageResponseHandler(payload) {
    if (!payload.requestOrderId || !this._responseCallbacks[payload.requestOrderId]) {
      throw new Error(`received response has unknown orderId: ${payload.requestOrderId}`);
    }
    const callback = this._responseCallbacks[payload.requestOrderId];
    delete this._responseCallbacks[payload.requestOrderId];
    callback(payload.data);
  }
  _setResponseCallback(orderId, callback) {
    this._responseCallbacks[orderId] = callback;
  }
  _setOrderAcceptedCallback(orderId, callback) {
    this._orderAcceptedCallbacks[orderId] = callback;
  }
  _setOrderRejectedCallback(orderId, callback) {
    this._orderRejectedCallbacks[orderId] = callback;
  }
  _clearOrderCallbacks(orderId) {
    delete this._orderAcceptedCallbacks[orderId];
    delete this._orderRejectedCallbacks[orderId];
  }
};
function validateData(data) {
  if (!data || typeof data !== "object") {
    throw new Error("the type of data must be object");
  }
}
function validateTarget(target) {
  if (!isMember(target)) {
    throw new Error("the type of target must be {id: string, name: string}");
  }
  if (!validate_default(target.id)) {
    throw new Error("the type of target.id must be uuid format");
  }
}

// src/utils/logger.ts
init_process();
export {
  Event,
  MessageClient
};
