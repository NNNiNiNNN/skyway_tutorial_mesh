"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageClient = void 0;
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const uuid_1 = require("uuid");
const order_1 = require("./order");
const payloadTypes_1 = require("./payloadTypes");
const socket_1 = require("./socket");
const event_1 = require("./utils/event");
const MSAS_DOMAIN = 'b-msas.beta.skyway.ntt.com';
const API_VERSION = 'v1';
class MessageClient {
    constructor({ token, channelId, channelName, memberId, memberName }, options) {
        this.onConnectionFailed = new event_1.Event();
        this.onRequested = new event_1.Event();
        this.onIndicated = new event_1.Event();
        this._responseCallbacks = {};
        this._orderAcceptedCallbacks = {};
        this._orderRejectedCallbacks = {};
        this._token = token;
        this._channelId = channelId;
        this._channelName = channelName;
        this._memberId = memberId;
        this._memberName = memberName;
        const defaultOptions = {
            connectivityCheckIntervalSec: 30,
            msasDomain: MSAS_DOMAIN,
            secure: true,
            logger: {
                debug: (message) => {
                    console.debug(message);
                },
                error: (error) => {
                    console.error(error);
                },
            },
        };
        this._options = Object.assign({}, defaultOptions, options !== null && options !== void 0 ? options : {});
        this._logger = this._options.logger;
        this._logger.debug(`Created instance with the options: ${this._options}`);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const RESTProtocol = this._options.secure ? 'https' : 'http';
            const queryString = `channelId=${this._channelId}`;
            let sessionDomain;
            try {
                const response = yield (0, isomorphic_fetch_1.default)(`${RESTProtocol}://${this._options.msasDomain}/${API_VERSION}/sessions?${queryString}`, {
                    headers: {
                        Authorization: `Bearer ${this._token}`,
                    },
                }).then((res) => res.json());
                sessionDomain = response.domain;
            }
            catch (error) {
                console.error(error);
            }
            if (!sessionDomain) {
                throw new Error('The response from SkyWay Server (MSAS) is empty');
            }
            const WSProtocol = this._options.secure ? 'wss' : 'ws';
            this._socket = new socket_1.Socket({
                sessionEndpoint: `${WSProtocol}://${sessionDomain}/${API_VERSION}/ws`,
                channelId: this._channelId,
                channelName: this._channelName,
                memberId: this._memberId,
                memberName: this._memberName,
                token: this._token,
                connectivityCheckIntervalSec: this._options.connectivityCheckIntervalSec,
                logger: this._logger,
            });
            this._socket.onEventReceived.addListener((data) => {
                this._eventReceivedHandler(data);
            });
            this._socket.onConnectionFailed.addListener(() => {
                this.onConnectionFailed.emit();
            });
            yield this._socket.onOpened.asPromise(15 * 1000);
            this._startConnectivityCheck();
            // TODO: 接続失敗時の処理
        });
    }
    disconnect() {
        var _a;
        this._stopConnectivityCheck();
        (_a = this._socket) === null || _a === void 0 ? void 0 : _a.destroy();
        this._socket = undefined;
    }
    _startConnectivityCheck() {
        if (this._connectivityCheckTimer) {
            this._logger.debug('connectivity check timer is already set');
            return;
        }
        this._connectivityCheckTimer = setInterval(() => {
            var _a;
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.send(new order_1.Order('connectivityCheck')).catch(() => { });
        }, this._options.connectivityCheckIntervalSec * 1000);
        this._logger.debug('Started connectivity check timer');
    }
    _stopConnectivityCheck() {
        if (!this._connectivityCheckTimer) {
            this._logger.debug('connectivity check timer is not set');
            return;
        }
        clearInterval(this._connectivityCheckTimer);
        this._connectivityCheckTimer = undefined;
        this._logger.debug('Stopped connectivity check timer');
    }
    indicate(targets, data, timeoutSec = 10) {
        return new Promise((resolve, reject) => {
            if (!Array.isArray(targets)) {
                targets = [targets];
            }
            if (targets.length === 0) {
                reject(new Error('targets is empty'));
                return;
            }
            for (const target of targets) {
                validateTarget(target);
            }
            validateData(data);
            if (this._socket === undefined) {
                reject(new Error('websocket is not connected'));
                return;
            }
            const payload = {
                kind: 'indicate',
                isBroadcast: false,
                dst: targets,
                data,
            };
            const order = new order_1.Order('message', payload);
            const timer = setTimeout(() => {
                this._clearOrderCallbacks(order.id);
                reject(new Error('indicate timeout'));
            }, timeoutSec * 1000);
            this._setOrderAcceptedCallback(order.id, () => {
                clearTimeout(timer);
                resolve();
            });
            this._setOrderRejectedCallback(order.id, (data) => {
                clearTimeout(timer);
                reject(data);
            });
            this._socket.send(order).catch((err) => {
                this._clearOrderCallbacks(order.id);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    indicateAll(data, timeoutSec = 10) {
        return new Promise((resolve, reject) => {
            validateData(data);
            if (this._socket === undefined) {
                reject(new Error('websocket is not connected'));
                return;
            }
            const payload = {
                kind: 'indicate',
                isBroadcast: true,
                data,
            };
            const order = new order_1.Order('message', payload);
            const timer = setTimeout(() => {
                this._clearOrderCallbacks(order.id);
                reject(new Error('indicateAll timeout'));
            }, timeoutSec * 1000);
            this._setOrderAcceptedCallback(order.id, () => {
                clearTimeout(timer);
                resolve();
            });
            this._setOrderRejectedCallback(order.id, (data) => {
                clearTimeout(timer);
                reject(data);
            });
            this._socket.send(order).catch((err) => {
                this._clearOrderCallbacks(order.id);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    request(target, data, timeoutSec = 10) {
        validateTarget(target);
        validateData(data);
        return new Promise((resolve, reject) => {
            if (this._socket === undefined) {
                reject(new Error('websocket is not connected'));
                return;
            }
            const payload = {
                kind: 'request',
                dst: target,
                data,
            };
            const order = new order_1.Order('message', payload);
            const timer = setTimeout(() => {
                delete this._responseCallbacks[order.id];
                delete this._orderRejectedCallbacks[order.id];
                reject(new Error('request timeout'));
            }, timeoutSec * 1000);
            this._setResponseCallback(order.id, (data) => {
                clearTimeout(timer);
                resolve(data);
            });
            this._setOrderRejectedCallback(order.id, (data) => {
                clearTimeout(timer);
                reject(data);
            });
            this._setOrderAcceptedCallback(order.id, () => {
                // Do nothing. Because promise will be resolved when receive response
            });
            this._socket.send(order).catch((err) => {
                delete this._responseCallbacks[order.id];
                delete this._orderRejectedCallbacks[order.id];
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    _response(target, requestOrderId, data, timeoutSec) {
        return new Promise((resolve, reject) => {
            validateData(data);
            if (this._socket === undefined) {
                reject(new Error('websocket is not connected'));
                return;
            }
            const payload = {
                kind: 'response',
                dst: target,
                requestOrderId,
                data,
            };
            const order = new order_1.Order('message', payload);
            const timer = setTimeout(() => {
                this._clearOrderCallbacks(order.id);
                reject(new Error('response timeout'));
            }, timeoutSec * 1000);
            this._setOrderAcceptedCallback(order.id, () => {
                clearTimeout(timer);
                resolve();
            });
            this._setOrderRejectedCallback(order.id, (data) => {
                clearTimeout(timer);
                reject(data);
            });
            this._socket.send(order).catch((err) => {
                this._clearOrderCallbacks(order.id);
                clearTimeout(timer);
                reject(err);
            });
        });
    }
    _eventReceivedHandler(data) {
        switch (data.event) {
            case 'orderAccepted':
                this._orderAcceptedHandler(data.payload);
                break;
            case 'orderRejected':
                this._orderRejectedHandler(data.payload);
                break;
            case 'message':
                this._eventMessageHandler(data.payload);
                break;
        }
    }
    _orderAcceptedHandler(payload) {
        if (!(0, payloadTypes_1.isOrderAcceptedPayload)(payload)) {
            throw new Error('Invalid payload');
        }
        const orderId = payload.orderId;
        if (!this._orderAcceptedCallbacks[orderId]) {
            throw new Error(`accepted event has unknown orderId: ${orderId}`);
        }
        const callback = this._orderAcceptedCallbacks[orderId];
        this._clearOrderCallbacks(orderId);
        callback();
    }
    _orderRejectedHandler(payload) {
        if (!(0, payloadTypes_1.isOrderRejectedPayload)(payload)) {
            throw new Error('Invalid payload');
        }
        const orderId = payload.orderId;
        if (!this._orderRejectedCallbacks[orderId]) {
            throw new Error(`rejected event has unknown orderId: ${orderId}`);
        }
        const callback = this._orderRejectedCallbacks[orderId];
        this._clearOrderCallbacks(orderId);
        callback(payload);
    }
    _eventMessageHandler(payload) {
        if (!(0, payloadTypes_1.isMessagePayload)(payload)) {
            throw new Error('Invalid payload');
        }
        switch (payload.kind) {
            case 'indicate':
                this._eventMessageIndicateHandler(payload);
                break;
            case 'request':
                this._eventMessageRequestHandler(payload);
                break;
            case 'response':
                this._eventMessageResponseHandler(payload);
                break;
        }
    }
    _eventMessageIndicateHandler(payload) {
        this.onIndicated.emit({
            data: payload.data,
            src: payload.src,
        });
    }
    _eventMessageRequestHandler(payload) {
        if (!payload.requestOrderId) {
            throw new Error('Invalid payload');
        }
        const src = payload.src;
        const requestOrderId = payload.requestOrderId;
        const reply = (data, timeout = 10) => __awaiter(this, void 0, void 0, function* () {
            yield this._response(src, requestOrderId, data, timeout);
        });
        this.onRequested.emit({
            data: payload.data,
            reply: reply,
            requestOrderId: payload.requestOrderId,
            src: payload.src,
        });
    }
    _eventMessageResponseHandler(payload) {
        if (!payload.requestOrderId || !this._responseCallbacks[payload.requestOrderId]) {
            throw new Error(`received response has unknown orderId: ${payload.requestOrderId}`);
        }
        const callback = this._responseCallbacks[payload.requestOrderId];
        delete this._responseCallbacks[payload.requestOrderId];
        callback(payload.data);
    }
    _setResponseCallback(orderId, callback) {
        this._responseCallbacks[orderId] = callback;
    }
    _setOrderAcceptedCallback(orderId, callback) {
        this._orderAcceptedCallbacks[orderId] = callback;
    }
    _setOrderRejectedCallback(orderId, callback) {
        this._orderRejectedCallbacks[orderId] = callback;
    }
    _clearOrderCallbacks(orderId) {
        delete this._orderAcceptedCallbacks[orderId];
        delete this._orderRejectedCallbacks[orderId];
    }
}
exports.MessageClient = MessageClient;
function validateData(data) {
    if (!data || typeof data !== 'object') {
        throw new Error('the type of data must be object');
    }
}
function validateTarget(target) {
    if (!(0, payloadTypes_1.isMember)(target)) {
        throw new Error('the type of target must be {id: string, name: string}');
    }
    if (!(0, uuid_1.validate)(target.id)) {
        throw new Error('the type of target.id must be uuid format');
    }
}
//# sourceMappingURL=messageClient.js.map