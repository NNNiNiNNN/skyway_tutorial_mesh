"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSFURoomMemberImpl = void 0;
const common_1 = require("@skyway-sdk/common");
const core_1 = require("@skyway-sdk/core");
const sfu_client_1 = require("@skyway-sdk/sfu-client");
const const_1 = require("../../const");
const base_1 = require("./base");
const log = new common_1.Logger('packages/room/src/member/local/sfu.ts');
/**@internal */
class LocalSFURoomMemberImpl extends base_1.LocalRoomMemberImpl {
    /**@private */
    constructor(member, room) {
        super(member, room);
    }
    publish(stream, options = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (stream instanceof core_1.LocalDataStream) {
                throw new common_1.SkyWayError({ type: 'invalidType', message: 'not supported' });
            }
            log.debug('[start] LocalSFURoomMemberImpl publish');
            try {
                options.maxSubscribers = (_a = options.maxSubscribers) !== null && _a !== void 0 ? _a : const_1.defaultMaxSubscribers;
                options.policy = (_b = options.policy) !== null && _b !== void 0 ? _b : 'tile';
                if (options.policy === 'tile') {
                    let short = stream.track.getSettings().width;
                    if (short > stream.track.getSettings().height) {
                        short = stream.track.getSettings().height;
                    }
                    const res = calcResolutionByMaxSubscribers(options.maxSubscribers);
                    let ratio = 1;
                    if (short > res) {
                        ratio = Math.floor(short / res);
                    }
                    log.debug('original encodings', JSON.stringify(options.encodings));
                    if (options.encodings) {
                        options.encodings = options.encodings.map((e) => {
                            var _a;
                            if ((_a = e.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 0 > ratio)
                                return e;
                            return Object.assign(Object.assign({}, e), { scaleResolutionDownBy: ratio });
                        });
                    }
                    else {
                        options.encodings = [{ scaleResolutionDownBy: ratio }];
                    }
                    log.debug('new encodings', JSON.stringify(options.encodings));
                }
                const origin = yield this._local.publish(stream, options);
                const bot = this.room._channel.members.find((m) => m.subtype === sfu_client_1.SfuBotMember.subtype);
                if (!bot) {
                    throw new common_1.SkyWayError({ type: 'notFound', message: 'bot not found' });
                }
                const forwarding = yield bot.startForwarding(origin, {
                    maxSubscribers: options.maxSubscribers,
                });
                const relayingPublication = forwarding.relayingPublication;
                const roomPublication = this.room._addPublication(relayingPublication);
                this.onStreamPublished.emit({ publication: roomPublication });
                log.debug('[end] LocalSFURoomMemberImpl publish');
                return roomPublication;
            }
            catch (error) {
                throw new common_1.SkyWayError({
                    type: 'internalError',
                    message: '[failed] LocalSFURoomMemberImpl publish',
                    payload: { error, message: error === null || error === void 0 ? void 0 : error.message },
                });
            }
        });
    }
    /**
     * @description {japanese} Room上のStreamをUnPublishする
     */
    unpublish(publicationId) {
        return __awaiter(this, void 0, void 0, function* () {
            const publication = this.room._getPublication(publicationId);
            const origin = publication._publication.origin;
            if (!origin) {
                throw new common_1.SkyWayError({
                    type: 'parameterMissing',
                    message: "sfu room's publication must has origin",
                });
            }
            this._local.unpublish(origin.id);
            yield this.room.onStreamUnpublished
                .watch((e) => e.publication.id === publicationId, core_1.SkyWayConfig.get.rtcApi.timeout)
                .catch(() => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'onStreamUnpublished',
                });
            });
            this.onStreamUnpublished.emit({ publication });
        });
    }
    /**
     * @description {japanese} MemberがRoom上のStreamのPublicationをSubscribeする
     */
    subscribe(publicationId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { subscription, stream } = yield this._local.subscribe(publicationId);
            const roomSubscription = this.room._addSubscription(subscription);
            return {
                subscription: roomSubscription,
                stream: stream,
            };
        });
    }
    /**
     * @description {japanese} MemberがSubscribeしているStreamのSubscriptionをUnSubscribeする
     */
    unsubscribe(subscriptionId) {
        return __awaiter(this, void 0, void 0, function* () {
            this._local.unsubscribe(subscriptionId);
            yield this.room.onStreamUnsubscribed
                .watch((e) => e.subscription.id === subscriptionId, core_1.SkyWayConfig.get.rtcApi.timeout)
                .catch(() => {
                throw new common_1.SkyWayError({
                    type: 'timeout',
                    message: 'onStreamUnsubscribed',
                });
            });
        });
    }
    _updateRoom(room) {
        log.debug('_updateRoom', { memberId: this.id });
        this.room = room;
        this._listenRoomEvent();
    }
}
exports.LocalSFURoomMemberImpl = LocalSFURoomMemberImpl;
function calcResolutionByMaxSubscribers(max) {
    const baseResolution = 1080;
    const row = Math.floor(Math.sqrt(max));
    const resolution = Math.floor(baseResolution / row);
    return resolution;
}
//# sourceMappingURL=sfu.js.map