"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = exports.Event = void 0;
class Event {
    constructor(_onSetListener = () => { }) {
        this._onSetListener = _onSetListener;
        this._stack = [];
        this._eventIndex = 0;
        this.emit = (arg) => {
            this._stack.forEach((v) => v.execute(arg));
        };
        this.removeAllListeners = () => {
            this._stack = [];
        };
        this.pipe = (event) => {
            return this.add((arg) => event.emit(arg));
        };
        /**
         * イベントが起きた時に実行する関数を登録する。
         * 戻り値として関数の登録を解除する関数が帰ってくる
         */
        this.add = (callback) => {
            const id = this._eventIndex;
            this._stack.push({ execute: callback, id });
            this._eventIndex++;
            const removeListener = () => {
                this._stack = this._stack.filter((item) => item.id !== id && item);
            };
            this._onSetListener();
            return { removeListener };
        };
        /**イベントが起きた時に一度だけ実行される関数を登録する */
        this.once = (callback) => {
            const off = this.add((arg) => {
                off.removeListener();
                callback(arg);
            });
        };
        /**
         * イベントが起きた時に Promise が resolve される
         * @param timeLimit ms
         */
        this.asPromise = (timeLimit) => new Promise((resolve, reject) => {
            const timeout = timeLimit &&
                setTimeout(() => {
                    reject('Event asPromise timeout : ' + timeLimit);
                }, timeLimit);
            this.once((arg) => {
                if (timeout)
                    clearTimeout(timeout);
                resolve(arg);
            });
        });
        /**
         * イベントが起きた時に実行される boolean を返す関数を登録する。
         * 登録した関数が true を返した時に Promise が resolve される
         * */
        this.watch = (callback, timeLimit) => new Promise((resolve, reject) => {
            const timeout = timeLimit &&
                setTimeout(() => {
                    reject('Event watch timeout : ' + timeLimit);
                }, timeLimit);
            const { removeListener } = this.add((arg) => {
                const done = callback(arg);
                if (done) {
                    if (timeout)
                        clearTimeout(timeout);
                    removeListener();
                    resolve(arg);
                }
            });
        });
    }
    get length() {
        return this._stack.length;
    }
}
exports.Event = Event;
class Events {
    constructor() {
        this.events = [];
    }
    make() {
        const event = new Event();
        this.events.push(event);
        return event;
    }
    dispose() {
        this.events.forEach((event) => event.removeAllListeners());
        this.events = [];
    }
}
exports.Events = Events;
//# sourceMappingURL=event.js.map