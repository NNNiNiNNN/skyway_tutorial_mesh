"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SfuRestApiClient = void 0;
const common_1 = require("@skyway-sdk/common");
const const_1 = require("./const");
const log = new common_1.Logger('packages/sfu-client/src/api.ts');
class SfuRestApiClient {
    constructor(_token, _options = {}) {
        this._token = _token;
        this.options = Object.assign(Object.assign({}, const_1.defaultSfuApiOptions), _options);
        this.endpoint = `http${this.options.secure ? 's' : ''}://${this.options.domain}/v${this.options.version}`;
        this.http = new common_1.HttpClient(this.endpoint);
        common_1.Logger.level = this.options.logLevel;
        log.debug('SfuRestApiClient spawned', { endpoint: this.endpoint });
    }
    updateToken(token) {
        this._token = token;
    }
    createBot({ appId, channelId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.http
                .post('/bots', {
                appId,
                channelId,
            }, { headers: { authorization: `Bearer ${this._token}` } })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'createBot failed',
                            payload: { data: e === null || e === void 0 ? void 0 : e.data, status: e === null || e === void 0 ? void 0 : e.status },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'createBot failed',
                            payload: { data: e.message },
                        });
                }
            });
            return res.id;
        });
    }
    deleteBot({ botId }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.http
                .delete(`/bots/${botId}`, {
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'deleteBot failed',
                            payload: { data: e === null || e === void 0 ? void 0 : e.data, status: e === null || e === void 0 ? void 0 : e.status },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'deleteBot failed',
                            payload: { data: e.message },
                        });
                }
            });
        });
    }
    startForwarding({ botId, publicationId, maxSubscribers, contentType, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new BackOff();
            const res = yield this.http
                .post(`/bots/${botId}/forwardings`, {
                publicationId,
                maxSubscribers,
                // todo fix
                contentType: contentType[0].toUpperCase() + contentType.slice(1),
            }, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'startForwarding failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                            },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'startForwarding failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                                retry: backOff.retry,
                            },
                        });
                }
            });
            if (backOff.retry > 0) {
                log.warn('success to retry startForwarding', {
                    botId,
                    publicationId,
                    retry: backOff.retry,
                });
            }
            return res;
        });
    }
    createProducer({ botId, forwardingId, transportId, producerOptions, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new BackOff();
            const res = yield this.http
                .put(`/bots/${botId}/forwardings/${forwardingId}/transport/producer`, { transportId, producerOptions }, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'createProducer failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                            },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'createProducer failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                                retry: backOff.retry,
                            },
                        });
                }
            });
            if (backOff.retry > 0) {
                log.warn('success to retry createProducer', {
                    botId,
                    forwardingId,
                    transportId,
                    retry: backOff.retry,
                });
            }
            // todo fix
            return '';
        });
    }
    createConsumer({ botId, forwardingId, rtpCapabilities, subscriptionId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new BackOff();
            const requestPayload = { rtpCapabilities, subscriptionId };
            const res = yield this.http
                .post(`/bots/${botId}/forwardings/${forwardingId}/transport/consumers`, requestPayload, {
                retry: (err) => __awaiter(this, void 0, void 0, function* () {
                    if (err.status === 400) {
                        return false;
                    }
                    return yield backOff.wait();
                }),
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'createConsumer failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                            },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'createConsumer failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                                retry: backOff.retry,
                            },
                        });
                }
            });
            if (backOff.retry > 0) {
                log.warn('success to retry createConsumer', {
                    botId,
                    forwardingId,
                    retry: backOff.retry,
                });
            }
            return res;
        });
    }
    connect({ botId, forwardingId, transportId, dtlsParameters, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new BackOff();
            const res = yield this.http
                .put(`/bots/${botId}/forwardings/${forwardingId}/transport/connection`, { transportId, dtlsParameters }, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'connect failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                            },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'connect failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                                retry: backOff.retry,
                            },
                        });
                }
            });
            if (backOff.retry > 0) {
                log.warn('success to retry connect', {
                    botId,
                    forwardingId,
                    transportId,
                    retry: backOff.retry,
                });
            }
            return res;
        });
    }
    stopForwarding({ botId, forwardingId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.http
                .delete(`/bots/${botId}/forwardings/${forwardingId}`, {
                headers: { authorization: `Bearer ${this._token}` },
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'stopForwarding failed',
                            payload: { data: e === null || e === void 0 ? void 0 : e.data, status: e === null || e === void 0 ? void 0 : e.status },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'stopForwarding failed',
                            payload: { data: e.message },
                        });
                }
            });
        });
    }
    // async iceRestart({
    //   botId,
    //   forwardingId,
    //   transportId,
    // }: {
    //   botId: string;
    //   forwardingId: string;
    //   transportId: string;
    // }) {
    //   const res = await this.http
    //     .put<{ iceParameters: object }>(
    //       `/bots/${botId}/forwardings/${forwardingId}/transport/ice`,
    //       { headers: { authorization: `Bearer ${this._token}` } }
    //     )
    //     .catch((e: HttpResponse) => {
    //       switch (e?.status) {
    //         case 403:
    //           throw new SkyWayError({
    //             type: 'insufficientPermissions',
    //             message: 'iceRestart failed',
    //             payload: { data: e?.data, status: e?.status },
    //           });
    //         default:
    //           throw new SkyWayError({
    //             type: 'backendError',
    //             message: 'iceRestart failed',
    //             payload: { data: e?.data, status: e?.status },
    //           });
    //       }
    //     });
    //   return res.iceParameters;
    // }
    getCapabilities({ botId, forwardingId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const backOff = new BackOff();
            const res = yield this.http
                .get(`/bots/${botId}/forwardings/${forwardingId}/transport/rtp_capabilities`, {
                headers: { authorization: `Bearer ${this._token}` },
                retry: () => __awaiter(this, void 0, void 0, function* () {
                    return yield backOff.wait();
                }),
            })
                .catch((e) => {
                switch (e === null || e === void 0 ? void 0 : e.status) {
                    case 403:
                        throw new common_1.SkyWayError({
                            type: 'insufficientPermissions',
                            message: 'getCapabilities failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                            },
                        });
                    default:
                        throw new common_1.SkyWayError({
                            type: 'backendError',
                            message: 'getCapabilities failed',
                            payload: {
                                data: e === null || e === void 0 ? void 0 : e.data,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                status: e === null || e === void 0 ? void 0 : e.status,
                                retry: backOff.retry,
                            },
                        });
                }
            });
            if (backOff.retry > 0) {
                log.warn('getCapabilities to retry connect', {
                    botId,
                    forwardingId,
                    retry: backOff.retry,
                });
            }
            return res.routerRtpCapabilities;
        });
    }
}
exports.SfuRestApiClient = SfuRestApiClient;
class BackOff {
    // todo config
    // 20.4 sec {var sum=0;for(i=0;i<=8;i++){sum+=i**2*100}}
    constructor(times = 8) {
        this.times = times;
        this.retry = 0;
    }
    wait() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.retry++ > this.times) {
                return false;
            }
            const timeout = Math.pow(this.retry, 2) * 100;
            yield new Promise((r) => setTimeout(r, timeout));
            return true;
        });
    }
}
//# sourceMappingURL=api.js.map